# syntax=docker/dockerfile:1.6

# Используем официальный python:3.12-slim и отказываемся от сложной
# двухстадийной сборки на базе Ubuntu. Это устраняет периодические падения
# docker buildx на шаге docker-publish, связанные с ``apt upgrade`` и
# зависимостями Ubuntu, и минимизирует число внешних точек отказа. Теперь мы
# работаем с минимальной средой, поставляемой самим образом Python. Чтобы
# совместить образ с зафиксированным в CI BuildKit ``moby/buildkit:v0.25.0``
# (см. ``.github/workflows/docker-publish.yml``), придерживаемся стабильного
# синтаксиса Dockerfile 1.6 без ``-labs``. Версия 1.7-labs требует более
# нового BuildKit и приводила к мгновенному «failed to solve: dockerfile parse
# error» при запуске workflow.
FROM --platform=linux/amd64 python:3.12-slim AS base

ENV PYTHONUNBUFFERED=1

ARG DEBIAN_FRONTEND=noninteractive

RUN <<'EOSHELL'
set -euxo pipefail
apt-get update \
    && apt-get install -y --no-install-recommends \
        ca-certificates \
        curl \
        git \
        patch \
    && rm -rf /var/lib/apt/lists/*
EOSHELL

WORKDIR /app

# Устанавливаем изолированное виртуальное окружение, заранее подтягивая
# обновлённые версии pip/setuptools. pip>=25.2 доступен на момент написания; ниже
# мы патчим установленный pip, добавляя проверку символических ссылок из 25.3
# (исправление CVE-2025-8869).
RUN <<'EOSHELL'
set -euxo pipefail
python -m venv /venv
/venv/bin/python -m ensurepip --upgrade
/venv/bin/pip install --no-cache-dir \
    'pip>=25.2' \
    'setuptools>=80.9.0,<81' \
    wheel
/venv/bin/python - <<'PY'
from __future__ import annotations

import os
import tarfile
from pathlib import Path

import pip

unpacking = Path(pip.__file__).resolve().parent / "_internal" / "utils" / "unpacking.py"
text = unpacking.read_text()

if "def is_symlink_target_in_tar(" not in text:
    helper = (
        "\n\n"
        "def is_symlink_target_in_tar(tar: tarfile.TarFile, tarinfo: tarfile.TarInfo) -> bool:\n"
        "    \"\"\"Check if the file pointed to by the symbolic link is in the tar archive.\"\"\"\n"
        "    linkname = os.path.join(os.path.dirname(tarinfo.name), tarinfo.linkname)\n"
        "    linkname = os.path.normpath(linkname)\n"
        "    linkname = linkname.replace(\\"\\\\\\", \\\"/\\")\n"
        "    try:\n"
        "        tar.getmember(linkname)\n"
        "        return True\n"
        "    except KeyError:\n"
        "        return False\n"
        "\n"
    )
    text = text.replace("def _untar_without_filter(", helper + "def _untar_without_filter(", 1)

    sentinel = '    """Fallback for Python without tarfile.data_filter"""\n'
    comment = (
        "    # NOTE: This function can be removed once pip requires CPython ≥ 3.12.\n"
        "    # PEP 706 added tarfile.data_filter, made tarfile extraction operations more secure.\n"
        "    # This feature is fully supported from CPython 3.12 onward.\n"
    )
    if sentinel + "    for member" not in text:
        raise SystemExit("unexpected pip layout: missing fallback header")
    text = text.replace(sentinel + "    for member", sentinel + comment + "    for member", 1)

    old_block = (
        "        elif member.issym():\n"
        "            try:\n"
        "                tar._extract_member(member, path)\n"
    )
    new_block = (
        "        elif member.issym():\n"
        "            if not is_symlink_target_in_tar(tar, member):\n"
        "                message = (\n"
        "                    \"The tar file ({}) has a file ({}) trying to install \"\n"
        "                    \"outside target directory ({})\"\n"
        "                )\n"
        "                raise InstallationError(\n"
        "                    message.format(filename, member.name, member.linkname)\n"
        "                )\n"
        "            try:\n"
        "                tar._extract_member(member, path)\n"
    )
    if old_block not in text:
        raise SystemExit("unexpected pip layout: missing symlink branch")
    text = text.replace(old_block, new_block, 1)

    unpacking.write_text(text)
PY
/venv/bin/pip cache purge
rm -rf /root/.cache/pip
EOSHELL

# Copy files required for static analysis
COPY .pre-commit-config.yaml .flake8 .pylintrc requirements-core.txt requirements-gpu.txt ./
COPY *.py ./
COPY scripts scripts
COPY services services
COPY tests tests

ENV PATH="/venv/bin:$PATH"

# Выделенный системный пользователь внутри контейнера
RUN groupadd --system bot \
    && useradd --system --gid bot --home-dir /home/bot --shell /bin/bash bot \
    && mkdir -p /home/bot \
    && chown -R bot:bot /app /home/bot /venv

USER bot

CMD ["bash"]

