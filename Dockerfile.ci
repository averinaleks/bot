# syntax=docker/dockerfile:1.6

# Используем официальный python:3.12-slim и отказываемся от сложной
# двухстадийной сборки на базе Ubuntu. Это устраняет периодические падения
# docker buildx на шаге docker-publish, связанные с ``apt upgrade`` и
# зависимостями Ubuntu, и минимизирует число внешних точек отказа. Теперь мы
# работаем с минимальной средой, поставляемой самим образом Python. Чтобы
# совместить образ с зафиксированным в CI BuildKit ``moby/buildkit:v0.25.0``
# (см. ``.github/workflows/docker-publish.yml``), придерживаемся стабильного
# синтаксиса Dockerfile 1.6 без ``-labs``. Версия 1.7-labs требует более
# нового BuildKit и приводила к мгновенному «failed to solve: dockerfile parse
# error» при запуске workflow.
FROM --platform=linux/amd64 python:3.12-slim AS base

ENV PYTHONUNBUFFERED=1

ARG DEBIAN_FRONTEND=noninteractive

RUN <<'EOSHELL'
set -euxo pipefail
apt-get update \
    && apt-get install -y --no-install-recommends \
        ca-certificates \
        curl \
        git \
        patch \
    && rm -rf /var/lib/apt/lists/*
EOSHELL

WORKDIR /app

# Устанавливаем изолированное виртуальное окружение, заранее подтягивая
# обновлённые версии pip/setuptools. pip>=25.2 доступен на момент написания; ниже
# мы патчим установленный pip, добавляя проверку символических ссылок из 25.3
# (исправление CVE-2025-8869).
RUN <<'EOSHELL'
set -euxo pipefail
python -m venv /venv
/venv/bin/python -m ensurepip --upgrade
/venv/bin/pip install --no-cache-dir \
    'pip>=25.2' \
    'setuptools>=80.9.0,<81' \
    wheel
/venv/bin/python - <<'PY'
from __future__ import annotations

import os
import tarfile
from pathlib import Path

import pip

unpacking = Path(pip.__file__).resolve().parent / "_internal" / "utils" / "unpacking.py"
source = unpacking.read_text()

if "def is_symlink_target_in_tar(" in source:
    print("pip tar symlink guard already present; skipping patch")
else:
    helper = "\n".join([
        "",
        "def is_symlink_target_in_tar(tar: tarfile.TarFile, tarinfo: tarfile.TarInfo) -> bool:",
        '    """Check if the file pointed to by the symbolic link is in the tar archive."""',
        "    linkname = os.path.join(os.path.dirname(tarinfo.name), tarinfo.linkname)",
        "    linkname = os.path.normpath(linkname)",
        '    linkname = linkname.replace("\\", "/")',
        "    try:",
        "        tar.getmember(linkname)",
        "        return True",
        "    except KeyError:",
        "        return False",
        "",
    ])
    comment = "\n".join([
        "    # NOTE: This function can be removed once pip requires CPython ≥ 3.12.",
        "    # PEP 706 added tarfile.data_filter, made tarfile extraction operations more secure.",
        "    # This feature is fully supported from CPython 3.12 onward.",
    ])
    sentinel_options = [
        '    """Fallback for Python without tarfile.data_filter"""',
        '    """Fallback for Python without tarfile.data_filter."""',
    ]
    sentinel = next((option for option in sentinel_options if option in source), None)

    if sentinel is None:
        print("::warning::pip layout changed; fallback docstring not found; skipping symlink guard patch")
    else:
        target_header = f"{sentinel}\n    for member"
        if target_header not in source:
            print("::warning::pip layout changed; fallback loop header not found; skipping symlink guard patch")
        else:
            old_variants = [
                "        elif member.issym():\n            try:\n                tar._extract_member(member, path)\n",
            ]
            for old in old_variants:
                if old in source:
                    new_block = "\n".join([
                        "        elif member.issym():",
                        "            if not is_symlink_target_in_tar(tar, member):",
                        "                message = (",
                        '                    "The tar file ({}) has a file ({}) trying to install "',
                        '                    "outside target directory ({})"',
                        "                )",
                        "                raise InstallationError(",
                        "                    message.format(filename, member.name, member.linkname)",
                        "                )",
                        "            try:",
                        "                tar._extract_member(member, path)",
                    ])
                    updated = source.replace("def _untar_without_filter(", helper + "def _untar_without_filter(", 1)
                    updated = updated.replace(
                        target_header,
                        f"{sentinel}\n{comment}\n    for member",
                        1,
                    )
                    updated = updated.replace(old, new_block, 1)
                    unpacking.write_text(updated)
                    print("Patched pip tar symlink extraction guard")
                    break
            else:
                print("::warning::pip layout changed; symlink branch not found; skipping symlink guard patch")

PY
/venv/bin/pip cache purge
rm -rf /root/.cache/pip
EOSHELL

# Copy files required for static analysis
COPY .pre-commit-config.yaml .flake8 .pylintrc requirements-core.txt requirements-gpu.txt ./
COPY *.py ./
COPY scripts scripts
COPY services services
COPY tests tests

ENV PATH="/venv/bin:$PATH"

# Выделенный системный пользователь внутри контейнера
RUN groupadd --system bot \
    && useradd --system --gid bot --home-dir /home/bot --shell /bin/bash bot \
    && mkdir -p /home/bot \
    && chown -R bot:bot /app /home/bot /venv

USER bot

CMD ["bash"]

