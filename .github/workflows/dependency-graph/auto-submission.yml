name: dependency-submission-auto

on:
  workflow_dispatch:
  repository_dispatch:
    types:
      - "dependency-graph-auto-submission"
      - "auto-submission"
      - "dependency_graph_auto_submission"

permissions:
  contents: write
  security-events: write

jobs:
  submit:
    runs-on: ubuntu-latest
    steps:
      - name: Resolve event metadata
        id: event-metadata
        run: |
          python3 <<'PY'
          from __future__ import annotations

          import json
          import os
          from typing import Any, Iterable, Tuple

          _NULL_STRINGS = {"", "null", "none", "undefined", '""', "''"}


          def _normalise(value: Any) -> str:
              if value is None:
                  return ""
              if isinstance(value, str):
                  candidate = value.strip()
                  if not candidate or candidate.lower() in _NULL_STRINGS:
                      return ""
                  return candidate
              if isinstance(value, (int, float)):
                  candidate = str(value).strip()
                  if not candidate or candidate.lower() in _NULL_STRINGS:
                      return ""
                  return candidate
              return ""


          def _load_payload() -> dict[str, Any]:
              path = os.getenv("GITHUB_EVENT_PATH")
              if not path:
                  return {}
              try:
                  with open(path, "r", encoding="utf-8") as stream:
                      data = json.load(stream)
              except Exception:
                  return {}
              return data if isinstance(data, dict) else {}


          PAYLOAD = _load_payload()


          def _lookup(path: str) -> str:
              if not path:
                  return ""
              if path.startswith("env."):
                  return _normalise(os.getenv(path.split(".", 1)[1]))
              current: Any = PAYLOAD
              for segment in path.split("."):
                  if segment == "payload":
                      continue
                  if isinstance(current, dict):
                      current = current.get(segment)
                  else:
                      return ""
              return _normalise(current)


          def _lines(block: str) -> Tuple[str, ...]:
              return tuple(
                  line.strip()
                  for line in block.splitlines()
                  if line.strip()
              )


          def _choose(candidates: Iterable[str]) -> str:
              for candidate in candidates:
                  value = _lookup(candidate)
                  if value:
                      return value
              return ""


          REF_CANDIDATES = _lines(
              """
              payload.ref
              payload.ref_name
              payload.refName
              payload.branch
              payload.branch_name
              payload.branchName
              payload.head_branch
              payload.headBranch
              payload.head_branch_name
              payload.headBranchName
              payload.head_ref
              payload.headRef
              payload.head_ref_name
              payload.headRefName
              env.GITHUB_HEAD_REF
              payload.dependency_graph.sha
              payload.dependency_graph.commit_oid
              payload.dependency_graph.commitOid
              payload.dependency_graph.ref
              payload.dependency_graph.ref_name
              payload.dependency_graph.refName
              payload.dependency_graph.branch
              payload.dependency_graph.branch_name
              payload.dependency_graph.branchName
              payload.client_payload.sha
              payload.client_payload.commit_sha
              payload.client_payload.commitSha
              payload.client_payload.commit_oid
              payload.client_payload.commitOid
              payload.client_payload.head_sha
              payload.client_payload.headSha
              payload.client_payload.after
              payload.client_payload.after_sha
              payload.client_payload.afterSha
              payload.client_payload.after_oid
              payload.client_payload.afterOid
              payload.client_payload.ref
              payload.client_payload.ref_name
              payload.client_payload.refName
              payload.client_payload.head_ref
              payload.client_payload.headRef
              payload.client_payload.head_ref_name
              payload.client_payload.headRefName
              payload.client_payload.branch
              payload.client_payload.branch_name
              payload.client_payload.branchName
              payload.workflow_run.head_sha
              payload.workflow_run.head_commit.id
              payload.workflow_run.head_commit.sha
              payload.workflow_run.head_commit.after
              payload.workflow_run.head_commit.afterSha
              payload.workflow_run.head_commit.afterOid
              payload.workflow_run.head_commit.afterCommitOid
              payload.workflow_run.head_ref
              payload.workflow_run.headRef
              payload.workflow_run.head_ref_name
              payload.workflow_run.headRefName
              payload.workflow_run.head_branch
              payload.workflow_run.head_branch_name
              payload.workflow_run.headBranch
              payload.workflow_run.headBranchName
              env.GITHUB_REF
              env.GITHUB_SHA
              """
          )

          checkout_ref = _choose(REF_CANDIDATES)
          if not checkout_ref:
              default_branch = _lookup("payload.repository.default_branch")
              if default_branch:
                  checkout_ref = f"refs/heads/{default_branch}"
          if not checkout_ref:
              checkout_ref = "refs/heads/main"

          BEFORE_CANDIDATES = _lines(
              """
              payload.before
              payload.dependency_graph.before_sha
              payload.dependency_graph.beforeSha
              payload.dependency_graph.before_oid
              payload.dependency_graph.beforeOid
              payload.dependency_graph.before_commit_oid
              payload.dependency_graph.beforeCommitOid
              payload.dependency_graph.base_ref
              payload.dependency_graph.base_sha
              payload.dependency_graph.baseRef
              payload.dependency_graph.baseRefName
              payload.dependency_graph.baseSha
              payload.client_payload.before
              payload.client_payload.before_sha
              payload.client_payload.beforeSha
              payload.client_payload.before_oid
              payload.client_payload.beforeOid
              payload.client_payload.before_commit_oid
              payload.client_payload.beforeCommitOid
              payload.client_payload.previous_sha
              payload.client_payload.previousSha
              payload.client_payload.previous_oid
              payload.client_payload.previousOid
              payload.client_payload.previous_commit_oid
              payload.client_payload.previousCommitOid
              payload.workflow_run.before
              payload.workflow_run.previous_sha
              payload.workflow_run.head_commit.before
              payload.workflow_run.head_commit.beforeSha
              payload.workflow_run.head_commit.beforeOid
              payload.workflow_run.head_commit.beforeCommitOid
              payload.workflow_run.head_commit.previousSha
              payload.workflow_run.head_commit.previousOid
              payload.workflow_run.head_commit.previousCommitOid
              """
          )

          AFTER_CANDIDATES = _lines(
              """
              env.GITHUB_SHA
              payload.commit_oid
              payload.commitOid
              payload.commit_sha
              payload.sha
              payload.dependency_graph.sha
              payload.dependency_graph.commit_oid
              payload.dependency_graph.commitOid
              payload.dependency_graph.after_sha
              payload.dependency_graph.afterSha
              payload.dependency_graph.after_oid
              payload.dependency_graph.afterOid
              payload.dependency_graph.after_commit_oid
              payload.dependency_graph.afterCommitOid
              payload.dependency_graph.after
              payload.client_payload.after
              payload.client_payload.head_sha
              payload.client_payload.headSha
              payload.client_payload.commit_oid
              payload.client_payload.commitOid
              payload.client_payload.commit_sha
              payload.client_payload.after_sha
              payload.client_payload.afterSha
              payload.client_payload.after_oid
              payload.client_payload.afterOid
              payload.client_payload.after_commit_oid
              payload.client_payload.afterCommitOid
              payload.client_payload.sha
              payload.workflow_run.head_sha
              payload.workflow_run.head_commit.id
              payload.workflow_run.head_commit.sha
              payload.workflow_run.head_commit.after
              payload.workflow_run.head_commit.afterSha
              payload.workflow_run.head_commit.afterOid
              payload.workflow_run.head_commit.afterCommitOid
              """
          )

          before = _choose(BEFORE_CANDIDATES)
          after = _choose(AFTER_CANDIDATES)

          output_path = os.getenv("GITHUB_OUTPUT")
          if output_path:
              with open(output_path, "a", encoding="utf-8") as stream:
                  stream.write(f"checkout_ref={checkout_ref}\n")
                  stream.write(f"before={before}\n")
                  stream.write(f"after={after}\n")

          print(f"Checkout reference resolved to: {checkout_ref}")
          if before:
              print(f"Resolved 'before' commit: {before}")
          if after:
              print(f"Resolved 'after' commit: {after}")
          PY
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v4
        with:
          fetch-depth: 0
          ref: ${{ steps.event-metadata.outputs.checkout_ref }}
      - uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: '3.11'
      - name: Detect dependency manifest changes
        id: detect
        env:
          BEFORE: ${{ steps.event-metadata.outputs.before }}
          AFTER: ${{ steps.event-metadata.outputs.after }}
      - name: Install dependency snapshot dependencies
        if: >-
          steps.detect.outputs.changed == 'true' ||
          github.event_name == 'workflow_dispatch' ||
          github.event_name == 'repository_dispatch'
        run: |
          python -m pip install --upgrade pip \
            || python -m pip install --upgrade pip --break-system-packages \
            || echo '::warning::Unable to upgrade pip; proceeding with the preinstalled version.'
          python -m pip install requests \
            || python -m pip install requests --break-system-packages \
            || echo '::warning::Unable to install requests; dependency snapshot submission may fail.'
      - name: Prepare requirements
        if: >-
          steps.detect.outputs.changed == 'true' ||
          github.event_name == 'workflow_dispatch' ||
          github.event_name == 'repository_dispatch'
        run: |
          python <<'PY'
          from __future__ import annotations

          import fnmatch
          import os
          from pathlib import Path
          from typing import Iterable

          patterns = ("requirements*.txt", "requirements*.in", "requirements*.out")
          excluded = {
              ".git",
              ".hg",
              ".nox",
              ".tox",
              ".venv",
              "__pycache__",
              "env",
              "node_modules",
              "site-packages",
              "venv",
          }

          def is_excluded(target: Path) -> bool:
              return any(part in excluded for part in target.parts)

          def iter_requirement_files(root: Path) -> Iterable[Path]:
              for current_root, dirnames, filenames in os.walk(root):
                  current_path = Path(current_root)
                  if is_excluded(current_path):
                      dirnames[:] = []
                      continue
                  dirnames[:] = sorted(
                      dirname
                      for dirname in dirnames
                      if not is_excluded(current_path / dirname)
                  )
                  for filename in filenames:
                      name_lower = filename.lower()
                      if not any(
                          fnmatch.fnmatch(filename, pattern)
                          or fnmatch.fnmatch(name_lower, pattern)
                          for pattern in patterns
                      ):
                          continue
                      yield current_path / filename

          for path in iter_requirement_files(Path(".")):
              try:
                  original = path.read_text(encoding="utf-8")
              except UnicodeDecodeError as exc:
                  print(
                      f"Skipping {path} due to encoding error: {exc}",
                      flush=True,
                  )
                  continue
              except OSError as exc:
                  print(
                      f"Skipping {path} due to filesystem error: {exc}",
                      flush=True,
                  )
                  continue
              lines = original.splitlines(keepends=True)
              filtered: list[str] = []
              for line in lines:
                  stripped = line.lstrip()
                  stripped_lower = stripped.lower()
                  if stripped_lower.startswith("ccxtpro"):
                      continue
                  if stripped_lower.startswith("#") and "ccxtpro" in stripped_lower:
                      continue
                  filtered.append(line)
              if filtered != lines:
                  updated = "".join(filtered)
                  try:
                      path.write_text(updated, encoding="utf-8")
                  except OSError as exc:
                      print(
                          f"::warning::Unable to update {path}: {exc}",
                          flush=True,
                      )
          PY
      - name: Submit dependency snapshot
        if: >-
          steps.detect.outputs.changed == 'true' ||
          github.event_name == 'workflow_dispatch' ||
          github.event_name == 'repository_dispatch'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: python scripts/submit_dependency_snapshot.py
