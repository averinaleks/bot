name: dependency-submission-auto-retry

on:
  workflow_run:
    workflows:
      - Automatic Dependency Submission (Python)
    types:
      - completed

permissions:
  actions: write
  contents: write

jobs:
  retry:
    if: >-
      github.event.workflow_run.conclusion == 'failure' &&
      github.event.workflow_run.run_attempt == 1 &&
      github.event.workflow_run.event == 'dynamic'
    runs-on: ubuntu-latest
    steps:
      - name: Diagnose workflow run
        run: |
          echo "Workflow run ID: ${{ github.event.workflow_run.id }}"
          echo "Head branch: ${{ github.event.workflow_run.head_branch }}"
          echo "Head SHA: ${{ github.event.workflow_run.head_sha }}"
          echo "Event: ${{ github.event.workflow_run.event }}"
      - name: Retry dependency submission
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          API_URL: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          RUN_ID: ${{ github.event.workflow_run.id }}
          RUN_ATTEMPT: ${{ github.event.workflow_run.run_attempt }}
          HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
          HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
        run: |
          python <<'PY'
          from __future__ import annotations

          import json
          import os
          import sys
          import time
          from typing import Any, Iterable
          from urllib.error import HTTPError
          from urllib.parse import quote
          from urllib.request import Request, urlopen

          def _env(name: str) -> str:
              value = os.getenv(name, "").strip()
              if not value:
                  print(f"::error::{name} is required but missing.", flush=True)
                  raise SystemExit(1)
              return value

          API_URL = os.getenv("API_URL", "https://api.github.com").rstrip("/")
          TOKEN = _env("GH_TOKEN")
          REPOSITORY = _env("REPOSITORY")
          RUN_ID = _env("RUN_ID")
          INITIAL_ATTEMPT = int(os.getenv("RUN_ATTEMPT", "1") or "1")
          HEAD_BRANCH = os.getenv("HEAD_BRANCH", "").strip()
          HEAD_SHA = os.getenv("HEAD_SHA", "").strip()

          OWNER_REPO = REPOSITORY.split("/", 1)
          if len(OWNER_REPO) != 2:
              print(f"::error::Invalid repository format: {REPOSITORY}", flush=True)
              raise SystemExit(1)
          OWNER, REPO = OWNER_REPO

          user_agent = os.getenv(
              "DEPENDENCY_SNAPSHOT_USER_AGENT",
              "averinaleks-bot-dependency-retry",
          ).strip() or "averinaleks-bot-dependency-retry"

          HEADERS = {
              "Authorization": f"Bearer {TOKEN}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": user_agent,
          }

          def _raw_request(method: str, path: str, data: dict[str, Any] | None = None) -> tuple[int, bytes]:
              url = f"{API_URL}{path}"
              req = Request(url, method=method, headers=HEADERS)
              if data is not None:
                  payload = json.dumps(data).encode("utf-8")
                  req.data = payload
                  req.add_header("Content-Type", "application/json")
              try:
                  with urlopen(req) as response:
                      status = response.getcode()
                      body = response.read()
              except HTTPError as exc:
                  status = exc.code
                  body = exc.read()
              return status, body

          def _request_json(
              method: str,
              path: str,
              *,
              data: dict[str, Any] | None = None,
              expected: Iterable[int] = (200,),
          ) -> tuple[int, Any]:
              status, body = _raw_request(method, path, data=data)
              if status not in expected:
                  text = body.decode("utf-8", "replace") if body else ""
                  raise RuntimeError(
                      f"Unexpected response {status} for {method} {path}: {text}"
                  )
              parsed: Any = None
              if body:
                  text = body.decode("utf-8", "replace")
                  try:
                      parsed = json.loads(text)
                  except json.JSONDecodeError:
                      parsed = text
              return status, parsed

          def _ensure_branch(branch: str, sha: str) -> bool:
              if not branch or not sha:
                  return False
              ref_segment = quote(f"heads/{branch}", safe="")
              status, _ = _raw_request(
                  "GET",
                  f"/repos/{REPOSITORY}/git/ref/{ref_segment}",
              )
              if status == 200:
                  print(f"Branch '{branch}' already exists.", flush=True)
                  return False
              if status != 404:
                  text = _.decode("utf-8", "replace") if _ else ""
                  raise RuntimeError(
                      f"Unable to verify branch '{branch}': HTTP {status}: {text}"
                  )
              print(
                  f"Branch '{branch}' is missing. Creating ref at {sha}.",
                  flush=True,
              )
              _, payload = _request_json(
                  "POST",
                  f"/repos/{REPOSITORY}/git/refs",
                  data={"ref": f"refs/heads/{branch}", "sha": sha},
                  expected=(201,),
              )
              if isinstance(payload, dict):
                  created_ref = payload.get("ref", "")
                  print(f"Created {created_ref}.", flush=True)
              return True

          def _trigger_rerun(run_id: str) -> None:
              print(f"Triggering rerun for workflow run {run_id}.", flush=True)
              status, _ = _raw_request(
                  "POST",
                  f"/repos/{REPOSITORY}/actions/runs/{run_id}/rerun",
              )
              if status not in {201, 202}:
                  raise RuntimeError(
                      f"Failed to trigger rerun: HTTP {status}: {_.decode('utf-8', 'replace') if _ else ''}"
                  )

          def _load_run(run_id: str) -> dict[str, Any]:
              _, data = _request_json(
                  "GET",
                  f"/repos/{REPOSITORY}/actions/runs/{run_id}",
              )
              if isinstance(data, dict):
                  return data
              raise RuntimeError("Unable to load workflow run metadata.")

          def _delete_branch(branch: str) -> None:
              ref_segment = quote(f"heads/{branch}", safe="")
              status, body = _raw_request(
                  "DELETE",
                  f"/repos/{REPOSITORY}/git/refs/{ref_segment}",
              )
              if status in {204, 404}:
                  if status == 204:
                      print(f"Deleted branch '{branch}'.", flush=True)
                  else:
                      print(
                          f"Branch '{branch}' already absent during cleanup.",
                          flush=True,
                      )
                  return
              text = body.decode("utf-8", "replace") if body else ""
              raise RuntimeError(
                  f"Failed to delete branch '{branch}': HTTP {status}: {text}"
              )

          created_branch = False
          if HEAD_BRANCH:
              try:
                  created_branch = _ensure_branch(HEAD_BRANCH, HEAD_SHA)
              except Exception as exc:
                  print(str(exc), file=sys.stderr, flush=True)
                  raise
          else:
              print("No head branch provided; proceeding without branch recovery.")

          try:
              _trigger_rerun(RUN_ID)
          except Exception as exc:
              print(str(exc), file=sys.stderr, flush=True)
              if created_branch and HEAD_BRANCH:
                  try:
                      _delete_branch(HEAD_BRANCH)
                  except Exception as cleanup_exc:
                      print(str(cleanup_exc), file=sys.stderr, flush=True)
              raise

          timeout_seconds = 15 * 60
          poll_interval = 10
          deadline = time.time() + timeout_seconds
          rerun_conclusion = ""
          rerun_attempt = INITIAL_ATTEMPT
          while time.time() < deadline:
              time.sleep(poll_interval)
              run_data = _load_run(RUN_ID)
              rerun_attempt = int(run_data.get("run_attempt") or 1)
              status = (run_data.get("status") or "").lower()
              conclusion = (run_data.get("conclusion") or "").lower()
              print(
                  f"Run attempt {rerun_attempt}: status={status or 'unknown'} conclusion={conclusion or 'unknown'}",
                  flush=True,
              )
              if rerun_attempt > INITIAL_ATTEMPT and status == "completed":
                  rerun_conclusion = conclusion
                  break
          else:
              if created_branch and HEAD_BRANCH:
                  try:
                      _delete_branch(HEAD_BRANCH)
                  except Exception as cleanup_exc:
                      print(str(cleanup_exc), file=sys.stderr, flush=True)
              raise RuntimeError("Timed out waiting for rerun to complete.")

          if created_branch and HEAD_BRANCH:
              try:
                  _delete_branch(HEAD_BRANCH)
              except Exception as cleanup_exc:
                  print(str(cleanup_exc), file=sys.stderr, flush=True)

          if rerun_attempt <= INITIAL_ATTEMPT:
              raise RuntimeError("Rerun did not start before timeout.")

          if rerun_conclusion != "success":
              raise RuntimeError(
                  "Dependency submission rerun did not succeed. Conclusion: "
                  f"{rerun_conclusion or 'unknown'}"
              )

          print("Dependency submission rerun completed successfully.", flush=True)
          PY
      - name: Summary
        if: success()
        run: echo "Automatic dependency submission rerun finished successfully."
