name: dependency-submission

on:
  push:
    branches:
      - main
  workflow_dispatch:
  repository_dispatch:
    types:
      # Custom type used by auto-submission hooks. GitHub restricts repository
      # dispatch event names to alphanumeric characters plus '-' and '_', so we
      # cannot include a '/' separator here.
      - "dependency-graph-auto-submission"
      # Backwards compatibility with older hooks that still emit the original
      # "auto-submission" event type directly.
      - "auto-submission"
      # Some integrations use underscores instead of hyphens.
      - "dependency_graph_auto_submission"
# NOTE: GitHub does not yet accept the experimental ``dependency_graph`` event
# key in workflow files for public repositories. Auto-submission payloads should
# therefore be forwarded via the repository dispatch hook declared above.

permissions:
  # Only the supported scopes for dependency snapshot submission; GitHub rejects
  # the legacy "dependency-graph" permission.
  contents: write
  security-events: write

jobs:
  submit:
    runs-on: ubuntu-latest
    steps:
      - name: Resolve event metadata
        id: event-metadata
        run: |
          python3 <<'PY'
          from __future__ import annotations

          import json
          import os
          from typing import Any, Iterable, Tuple

          _NULL_STRINGS = {"", "null", "none", "undefined", '""', "''"}


          def _normalise(value: Any) -> str:
              if value is None:
                  return ""
              if isinstance(value, str):
                  candidate = value.strip()
                  if not candidate or candidate.lower() in _NULL_STRINGS:
                      return ""
                  return candidate
              if isinstance(value, (int, float)):
                  candidate = str(value).strip()
                  if not candidate or candidate.lower() in _NULL_STRINGS:
                      return ""
                  return candidate
              return ""


          def _load_payload() -> dict[str, Any]:
              path = os.getenv("GITHUB_EVENT_PATH")
              if not path:
                  return {}
              try:
                  with open(path, "r", encoding="utf-8") as stream:
                      data = json.load(stream)
              except Exception:
                  return {}
              return data if isinstance(data, dict) else {}


          PAYLOAD = _load_payload()


          def _lookup(path: str) -> str:
              if not path:
                  return ""
              if path.startswith("env."):
                  return _normalise(os.getenv(path.split(".", 1)[1]))
              current: Any = PAYLOAD
              for segment in path.split("."):
                  if segment == "payload":
                      continue
                  if isinstance(current, dict):
                      current = current.get(segment)
                  else:
                      return ""
              return _normalise(current)


          def _lines(block: str) -> Tuple[str, ...]:
              return tuple(
                  line.strip()
                  for line in block.splitlines()
                  if line.strip()
              )


          def _choose(candidates: Iterable[str]) -> str:
              for candidate in candidates:
                  value = _lookup(candidate)
                  if value:
                      return value
              return ""


          REF_CANDIDATES = _lines(
              """
              payload.ref
              payload.ref_name
              payload.refName
              payload.branch
              payload.branch_name
              payload.branchName
              payload.head_branch
              payload.headBranch
              payload.head_branch_name
              payload.headBranchName
              payload.head_ref
              payload.headRef
              payload.head_ref_name
              payload.headRefName
              env.GITHUB_HEAD_REF
              payload.base_ref
              payload.dependency_graph.sha
              payload.dependency_graph.commit_oid
              payload.dependency_graph.commitOid
              payload.dependency_graph.ref
              payload.dependency_graph.ref_name
              payload.dependency_graph.refName
              payload.dependency_graph.branch
              payload.dependency_graph.branch_name
              payload.dependency_graph.branchName
              payload.client_payload.sha
              payload.client_payload.commit_sha
              payload.client_payload.commitSha
              payload.client_payload.commit_oid
              payload.client_payload.commitOid
              payload.client_payload.head_sha
              payload.client_payload.headSha
              payload.client_payload.after
              payload.client_payload.after_sha
              payload.client_payload.afterSha
              payload.client_payload.after_oid
              payload.client_payload.afterOid
              payload.client_payload.ref
              payload.client_payload.ref_name
              payload.client_payload.refName
              payload.client_payload.head_ref
              payload.client_payload.headRef
              payload.client_payload.head_ref_name
              payload.client_payload.headRefName
              payload.client_payload.branch
              payload.client_payload.branch_name
              payload.client_payload.branchName
              payload.workflow_run.head_sha
              payload.workflow_run.head_commit.id
              payload.workflow_run.head_commit.sha
              payload.workflow_run.head_commit.before
              payload.workflow_run.head_commit.beforeSha
              payload.workflow_run.head_ref
              payload.workflow_run.headRef
              payload.workflow_run.head_ref_name
              payload.workflow_run.headRefName
              payload.workflow_run.head_branch
              payload.workflow_run.head_branch_name
              payload.workflow_run.headBranch
              payload.workflow_run.headBranchName
              env.GITHUB_REF
              """
          )

          checkout_ref = _choose(REF_CANDIDATES)
          if not checkout_ref:
              default_branch = _lookup("payload.repository.default_branch")
              if default_branch:
                  checkout_ref = f"refs/heads/{default_branch}"
          if not checkout_ref:
              checkout_ref = "refs/heads/main"

          BEFORE_CANDIDATES = _lines(
              """
              payload.before
              payload.base_sha
              payload.base_ref
              payload.dependency_graph.before_sha
              payload.dependency_graph.beforeSha
              payload.dependency_graph.before_oid
              payload.dependency_graph.beforeOid
              payload.dependency_graph.before_commit_oid
              payload.dependency_graph.beforeCommitOid
              payload.dependency_graph.base_ref
              payload.dependency_graph.base_sha
              payload.dependency_graph.baseRef
              payload.dependency_graph.baseRefName
              payload.dependency_graph.baseSha
              payload.client_payload.before
              payload.client_payload.base_sha
              payload.client_payload.before_sha
              payload.client_payload.baseSha
              payload.client_payload.beforeSha
              payload.client_payload.before_oid
              payload.client_payload.beforeOid
              payload.client_payload.before_commit_oid
              payload.client_payload.beforeCommitOid
              payload.client_payload.previous_sha
              payload.client_payload.previous_oid
              payload.client_payload.previousSha
              payload.client_payload.previousOid
              payload.client_payload.previous_commit_oid
              payload.client_payload.previousCommitOid
              payload.previous_sha
              payload.previousSha
              payload.previous_oid
              payload.previousOid
              payload.previous_commit_oid
              payload.previousCommitOid
              payload.head_commit.before
              payload.head_commit.beforeSha
              payload.head_commit.beforeOid
              payload.head_commit.beforeCommitOid
              payload.head_commit.previousSha
              payload.head_commit.previousOid
              payload.head_commit.previousCommitOid
              payload.workflow_run.before
              payload.workflow_run.previous_sha
              payload.workflow_run.head_commit.before
              payload.workflow_run.head_commit.beforeSha
              payload.workflow_run.head_commit.beforeOid
              payload.workflow_run.head_commit.beforeCommitOid
              payload.workflow_run.head_commit.previousSha
              payload.workflow_run.head_commit.previousOid
              payload.workflow_run.head_commit.previousCommitOid
              """
          )

          AFTER_CANDIDATES = _lines(
              """
              env.GITHUB_SHA
              payload.commit_oid
              payload.commitOid
              payload.commit_sha
              payload.sha
              payload.dependency_graph.sha
              payload.dependency_graph.commit_oid
              payload.dependency_graph.commitOid
              payload.dependency_graph.after_sha
              payload.dependency_graph.afterSha
              payload.dependency_graph.after_oid
              payload.dependency_graph.afterOid
              payload.dependency_graph.after_commit_oid
              payload.dependency_graph.afterCommitOid
              payload.dependency_graph.after
              payload.head_sha
              payload.headSha
              payload.after
              payload.after_sha
              payload.afterSha
              payload.after_oid
              payload.afterOid
              payload.after_commit_oid
              payload.afterCommitOid
              payload.head_commit.id
              payload.head_commit.sha
              payload.head_commit.after
              payload.head_commit.afterSha
              payload.head_commit.afterOid
              payload.head_commit.afterCommitOid
              payload.dependency_graph.ref
              payload.ref
              payload.client_payload.after
              payload.client_payload.head_sha
              payload.client_payload.headSha
              payload.client_payload.commit_oid
              payload.client_payload.commitOid
              payload.client_payload.commit_sha
              payload.client_payload.after_sha
              payload.client_payload.afterSha
              payload.client_payload.after_oid
              payload.client_payload.afterOid
              payload.client_payload.after_commit_oid
              payload.client_payload.afterCommitOid
              payload.client_payload.sha
              payload.workflow_run.head_sha
              payload.workflow_run.head_commit.id
              payload.workflow_run.head_commit.sha
              payload.workflow_run.head_commit.after
              payload.workflow_run.head_commit.afterSha
              payload.workflow_run.head_commit.afterOid
              payload.workflow_run.head_commit.afterCommitOid
              """
          )

          before = _choose(BEFORE_CANDIDATES)
          after = _choose(AFTER_CANDIDATES)

          output_path = os.getenv("GITHUB_OUTPUT")
          if output_path:
              with open(output_path, "a", encoding="utf-8") as stream:
                  stream.write(f"checkout_ref={checkout_ref}\n")
                  stream.write(f"before={before}\n")
                  stream.write(f"after={after}\n")

          print(f"Checkout reference resolved to: {checkout_ref}")
          if before:
              print(f"Resolved 'before' commit: {before}")
          if after:
              print(f"Resolved 'after' commit: {after}")
          PY
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v4
        with:
          fetch-depth: 0
          ref: ${{ steps.event-metadata.outputs.checkout_ref }}
      - uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: '3.11'
      - name: Detect dependency manifest changes
        id: detect
        env:
          BEFORE: ${{ steps.event-metadata.outputs.before }}
          AFTER: ${{ steps.event-metadata.outputs.after }}
        run: |
          python <<'PY'
          from __future__ import annotations

          import fnmatch
          import os
          import subprocess
          from pathlib import Path
          from typing import Sequence

          _NULL_STRINGS = {"null", "none", "undefined", '""', "''"}

          def _normalise_value(raw: str | None) -> str:
              if not raw:
                  return ""
              candidate = raw.strip()
              if candidate.lower() in _NULL_STRINGS:
                  return ""
              return candidate

          patterns: Sequence[str] = (
              "requirements*.txt",
              "requirements*.in",
              "requirements*.out",
          )
          before = _normalise_value(os.environ.get("BEFORE"))
          after = _normalise_value(os.environ.get("AFTER"))

          diff_failed = False
          changed: list[str]

          if not after:
              print(
                  "::warning::Missing GITHUB_SHA value; assuming dependency manifests changed.",
                  flush=True,
              )
              diff_failed = True
              changed = []
          else:
              if not before or set(before) == {"0"}:
                  before = f"{after}^"

              try:
                  completed = subprocess.run(
                      ["git", "diff", "--name-only", before, after],
                      check=True,
                      stdout=subprocess.PIPE,
                      text=True,
                  )
              except subprocess.CalledProcessError as exc:
                  print(f"::warning::Unable to determine diff: {exc}", flush=True)
                  diff_failed = True
                  changed = []
              except Exception as exc:  # pragma: no cover - defensive guard for CI
                  print(
                      "::warning::Unexpected error while detecting manifest changes:",
                      exc,
                      flush=True,
                  )
                  diff_failed = True
                  changed = []
              else:
                  files = [
                      line.strip()
                      for line in completed.stdout.splitlines()
                      if line.strip()
                  ]
                  changed = []
                  for file in files:
                      if not file:
                          continue
                      try:
                          filename = Path(file).name
                      except Exception:
                          filename = file
                      file_lower = file.lower()
                      filename_lower = filename.lower()
                      if any(
                          fnmatch.fnmatch(file, pattern)
                          or fnmatch.fnmatch(filename, pattern)
                          or fnmatch.fnmatch(file_lower, pattern)
                          or fnmatch.fnmatch(filename_lower, pattern)
                          for pattern in patterns
                      ):
                          changed.append(file)

          changed_flag = "true" if diff_failed or bool(changed) else "false"
          output_path = os.environ.get("GITHUB_OUTPUT")
          if not output_path:
              print(
                  "::warning::GITHUB_OUTPUT is not available; downstream steps will be skipped.",
                  flush=True,
              )
          else:
              try:
                  with open(output_path, "a", encoding="utf-8") as stream:
                      stream.write(f"changed={changed_flag}\n")
                      if changed:
                          stream.write("files<<EOF\n")
                          stream.write("\n".join(changed))
                          stream.write("\nEOF\n")
              except OSError as exc:  # pragma: no cover - filesystem guard for CI
                  print(
                      "::warning::Unable to write change detection outputs:",
                      exc,
                      flush=True,
                  )

          if changed_flag == "true" and not changed and diff_failed:
              print(
                  "Diff calculation failed; proceeding with dependency snapshot submission.",
                  flush=True,
              )
          elif changed:
              print("Dependency manifest changes detected:", flush=True)
              for path in changed:
                  print(f"  - {path}", flush=True)
          else:
              print("No dependency manifest changes detected.", flush=True)
          PY
      - name: Install dependency snapshot dependencies
        if: >-
          steps.detect.outputs.changed == 'true' ||
          github.event_name == 'workflow_dispatch' ||
          github.event_name == 'repository_dispatch' ||
          github.event_name == 'dependency_graph'
        run: |
          python -m pip install --upgrade pip \
            || python -m pip install --upgrade pip --break-system-packages \
            || echo '::warning::Unable to upgrade pip; proceeding with the preinstalled version.'
          python -m pip install requests \
            || python -m pip install requests --break-system-packages \
            || echo '::warning::Unable to install requests; dependency snapshot submission may fail.'
      - name: Prepare requirements
        if: >-
          steps.detect.outputs.changed == 'true' ||
          github.event_name == 'workflow_dispatch' ||
          github.event_name == 'repository_dispatch' ||
          github.event_name == 'dependency_graph'
        run: |
          python <<'PY'
          from __future__ import annotations

          import fnmatch
          import os
          from pathlib import Path
          from typing import Iterable

          patterns = ("requirements*.txt", "requirements*.in", "requirements*.out")
          excluded = {
              ".git",
              ".hg",
              ".nox",
              ".tox",
              ".venv",
              "__pycache__",
              "env",
              "node_modules",
              "site-packages",
              "venv",
          }

          def is_excluded(target: Path) -> bool:
              return any(part in excluded for part in target.parts)

          def iter_requirement_files(root: Path) -> Iterable[Path]:
              for current_root, dirnames, filenames in os.walk(root):
                  current_path = Path(current_root)
                  if is_excluded(current_path):
                      dirnames[:] = []
                      continue
                  dirnames[:] = sorted(
                      dirname
                      for dirname in dirnames
                      if not is_excluded(current_path / dirname)
                  )
                  for filename in filenames:
                      name_lower = filename.lower()
                      if not any(
                          fnmatch.fnmatch(filename, pattern)
                          or fnmatch.fnmatch(name_lower, pattern)
                          for pattern in patterns
                      ):
                          continue
                      yield current_path / filename

          for path in iter_requirement_files(Path(".")):
              try:
                  original = path.read_text(encoding="utf-8")
              except UnicodeDecodeError as exc:
                  print(
                      f"Skipping {path} due to encoding error: {exc}",
                      flush=True,
                  )
                  continue
              except OSError as exc:
                  print(
                      f"Skipping {path} due to filesystem error: {exc}",
                      flush=True,
                  )
                  continue
              lines = original.splitlines(keepends=True)
              filtered: list[str] = []
              for line in lines:
                  stripped = line.lstrip()
                  stripped_lower = stripped.lower()
                  if stripped_lower.startswith("ccxtpro"):
                      continue
                  if stripped_lower.startswith("#") and "ccxtpro" in stripped_lower:
                      continue
                  filtered.append(line)
              if filtered != lines:
                  updated = "".join(filtered)
                  try:
                      path.write_text(updated, encoding="utf-8")
                  except OSError as exc:
                      print(
                          f"::warning::Unable to update {path}: {exc}",
                          flush=True,
                      )
          PY
      - name: Submit dependency snapshot
        if: >-
          steps.detect.outputs.changed == 'true' ||
          github.event_name == 'workflow_dispatch' ||
          github.event_name == 'repository_dispatch' ||
          github.event_name == 'dependency_graph'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: python scripts/submit_dependency_snapshot.py
