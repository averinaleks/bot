name: dependency-submission

on:
  push:
    branches:
      - main
  workflow_dispatch:
  repository_dispatch:
    types:
      # Custom type used by auto-submission hooks. GitHub restricts repository
      # dispatch event names to alphanumeric characters plus '-' and '_', so we
      # cannot include a '/' separator here.
      - "dependency-graph-auto-submission"
      # Backwards compatibility with older hooks that still emit the original
      # "auto-submission" event type directly.
      - "auto-submission"
      # Some integrations use underscores instead of hyphens.
      - "dependency_graph_auto_submission"
# NOTE: GitHub does not yet accept the experimental ``dependency_graph`` event
# key in workflow files for public repositories. Auto-submission payloads should
# therefore be forwarded via the repository dispatch hook declared above.

permissions:
  # Only the supported scopes for dependency snapshot submission; GitHub rejects
  # the legacy "dependency-graph" permission.
  contents: write
  security-events: write

jobs:
  submit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v4
        with:
          fetch-depth: 0
          ref: >-
            ${{
              github.event.ref ||
              github.event.ref_name ||
              github.event.refName ||
              github.event.branch ||
              github.event.branch_name ||
              github.event.head_ref ||
              github.event.base_ref ||
              github.event.dependency_graph.sha ||
              github.event.dependency_graph.commit_oid ||
              github.event.dependency_graph.commitOid ||
              github.event.dependency_graph.ref ||
              github.event.dependency_graph.ref_name ||
              github.event.dependency_graph.refName ||
              github.event.dependency_graph.branch ||
              github.event.dependency_graph.branch_name ||
              github.event.dependency_graph.branchName ||
              github.event.client_payload.sha ||
              github.event.client_payload.commit_sha ||
              github.event.client_payload.commitSha ||
              github.event.client_payload.commit_oid ||
              github.event.client_payload.commitOid ||
              github.event.client_payload.head_sha ||
              github.event.client_payload.headSha ||
              github.event.client_payload.after ||
              github.event.client_payload.after_sha ||
              github.event.client_payload.afterSha ||
              github.event.client_payload.after_oid ||
              github.event.client_payload.afterOid ||
              github.event.client_payload.ref ||
              github.event.client_payload.ref_name ||
              github.event.client_payload.refName ||
              github.event.client_payload.head_ref ||
              github.event.client_payload.headRef ||
              github.event.client_payload.head_ref_name ||
              github.event.client_payload.headRefName ||
              github.event.client_payload.branch ||
              github.event.client_payload.branch_name ||
              github.event.client_payload.branchName ||
              github.event.workflow_run.head_sha ||
              github.event.workflow_run.head_commit.id ||
              github.event.workflow_run.head_commit.sha ||
              github.event.workflow_run.head_commit.before ||
              github.event.workflow_run.head_commit.beforeSha ||
              github.event.workflow_run.head_ref ||
              github.event.workflow_run.headRef ||
              github.event.workflow_run.head_ref_name ||
              github.event.workflow_run.headRefName ||
              github.event.workflow_run.head_branch ||
              github.event.workflow_run.head_branch_name ||
              github.event.workflow_run.headBranch ||
              github.event.workflow_run.headBranchName ||
              github.ref ||
              (
                github.event.repository.default_branch &&
                format('refs/heads/{0}', github.event.repository.default_branch)
              ) ||
              'refs/heads/main'
            }}
      - uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: '3.11'
      - name: Detect dependency manifest changes
        id: detect
        env:
          BEFORE: >-
            ${{
              github.event.before ||
              github.event.base_sha ||
              github.event.base_ref ||
              github.event.dependency_graph.before_sha ||
              github.event.dependency_graph.beforeSha ||
              github.event.dependency_graph.before_oid ||
              github.event.dependency_graph.beforeOid ||
              github.event.dependency_graph.base_ref ||
              github.event.dependency_graph.base_sha ||
              github.event.dependency_graph.baseRef ||
              github.event.dependency_graph.baseRefName ||
              github.event.dependency_graph.baseSha ||
              github.event.client_payload.before ||
              github.event.client_payload.base_sha ||
              github.event.client_payload.before_sha ||
              github.event.client_payload.baseSha ||
              github.event.client_payload.beforeSha ||
              github.event.client_payload.before_oid ||
              github.event.client_payload.beforeOid ||
              github.event.client_payload.previous_sha ||
              github.event.client_payload.previous_oid ||
              github.event.client_payload.previousSha ||
              github.event.client_payload.previousOid ||
              github.event.workflow_run.before ||
              github.event.workflow_run.previous_sha ||
              github.event.workflow_run.head_commit.before ||
              github.event.workflow_run.head_commit.beforeSha ||
              github.event.workflow_run.head_commit.previousSha ||
              ''
            }}
          AFTER: >-
            ${{
              github.sha ||
              github.event.commit_oid ||
              github.event.commitOid ||
              github.event.commit_sha ||
              github.event.sha ||
              github.event.dependency_graph.sha ||
              github.event.dependency_graph.commit_oid ||
              github.event.dependency_graph.commitOid ||
              github.event.dependency_graph.after_sha ||
              github.event.dependency_graph.afterSha ||
              github.event.dependency_graph.after_oid ||
              github.event.dependency_graph.afterOid ||
              github.event.dependency_graph.after ||
              github.event.dependency_graph.ref ||
              github.event.ref ||
              github.event.client_payload.after ||
              github.event.client_payload.head_sha ||
              github.event.client_payload.headSha ||
              github.event.client_payload.commit_oid ||
              github.event.client_payload.commitOid ||
              github.event.client_payload.commit_sha ||
              github.event.client_payload.after_sha ||
              github.event.client_payload.afterSha ||
              github.event.client_payload.after_oid ||
              github.event.client_payload.afterOid ||
              github.event.client_payload.sha ||
              github.event.workflow_run.head_sha ||
              github.event.workflow_run.head_commit.id ||
              github.event.workflow_run.head_commit.sha ||
              github.event.workflow_run.head_commit.after ||
              github.event.workflow_run.head_commit.afterSha ||
              ''
            }}
        run: |
          python <<'PY'
          from __future__ import annotations

          import fnmatch
          import os
          import subprocess
          from pathlib import Path
          from typing import Sequence

          _NULL_STRINGS = {"null", "none", "undefined", '""', "''"}

          def _normalise_value(raw: str | None) -> str:
              if not raw:
                  return ""
              candidate = raw.strip()
              if candidate.lower() in _NULL_STRINGS:
                  return ""
              return candidate

          patterns: Sequence[str] = (
              "requirements*.txt",
              "requirements*.in",
              "requirements*.out",
          )
          before = _normalise_value(os.environ.get("BEFORE"))
          after = _normalise_value(os.environ.get("AFTER"))

          diff_failed = False
          changed: list[str]

          if not after:
              print(
                  "::warning::Missing GITHUB_SHA value; assuming dependency manifests changed.",
                  flush=True,
              )
              diff_failed = True
              changed = []
          else:
              if not before or set(before) == {"0"}:
                  before = f"{after}^"

              try:
                  completed = subprocess.run(
                      ["git", "diff", "--name-only", before, after],
                      check=True,
                      stdout=subprocess.PIPE,
                      text=True,
                  )
              except subprocess.CalledProcessError as exc:
                  print(f"::warning::Unable to determine diff: {exc}", flush=True)
                  diff_failed = True
                  changed = []
              except Exception as exc:  # pragma: no cover - defensive guard for CI
                  print(
                      "::warning::Unexpected error while detecting manifest changes:",
                      exc,
                      flush=True,
                  )
                  diff_failed = True
                  changed = []
              else:
                  files = [
                      line.strip()
                      for line in completed.stdout.splitlines()
                      if line.strip()
                  ]
                  changed = []
                  for file in files:
                      if not file:
                          continue
                      try:
                          filename = Path(file).name
                      except Exception:
                          filename = file
                      file_lower = file.lower()
                      filename_lower = filename.lower()
                      if any(
                          fnmatch.fnmatch(file, pattern)
                          or fnmatch.fnmatch(filename, pattern)
                          or fnmatch.fnmatch(file_lower, pattern)
                          or fnmatch.fnmatch(filename_lower, pattern)
                          for pattern in patterns
                      ):
                          changed.append(file)

          changed_flag = "true" if diff_failed or bool(changed) else "false"
          output_path = os.environ.get("GITHUB_OUTPUT")
          if not output_path:
              print(
                  "::warning::GITHUB_OUTPUT is not available; downstream steps will be skipped.",
                  flush=True,
              )
          else:
              try:
                  with open(output_path, "a", encoding="utf-8") as stream:
                      stream.write(f"changed={changed_flag}\n")
                      if changed:
                          stream.write("files<<EOF\n")
                          stream.write("\n".join(changed))
                          stream.write("\nEOF\n")
              except OSError as exc:  # pragma: no cover - filesystem guard for CI
                  print(
                      "::warning::Unable to write change detection outputs:",
                      exc,
                      flush=True,
                  )

          if changed_flag == "true" and not changed and diff_failed:
              print(
                  "Diff calculation failed; proceeding with dependency snapshot submission.",
                  flush=True,
              )
          elif changed:
              print("Dependency manifest changes detected:", flush=True)
              for path in changed:
                  print(f"  - {path}", flush=True)
          else:
              print("No dependency manifest changes detected.", flush=True)
          PY
      - name: Install dependency snapshot dependencies
        if: >-
          steps.detect.outputs.changed == 'true' ||
          github.event_name == 'workflow_dispatch' ||
          github.event_name == 'repository_dispatch' ||
          github.event_name == 'dependency_graph'
        run: |
          python -m pip install --upgrade pip \
            || python -m pip install --upgrade pip --break-system-packages
          python -m pip install requests \
            || python -m pip install requests --break-system-packages
      - name: Prepare requirements
        if: >-
          steps.detect.outputs.changed == 'true' ||
          github.event_name == 'workflow_dispatch' ||
          github.event_name == 'repository_dispatch' ||
          github.event_name == 'dependency_graph'
        run: |
          python <<'PY'
          from __future__ import annotations

          import fnmatch
          import os
          from pathlib import Path
          from typing import Iterable

          patterns = ("requirements*.txt", "requirements*.in", "requirements*.out")
          excluded = {
              ".git",
              ".hg",
              ".nox",
              ".tox",
              ".venv",
              "__pycache__",
              "env",
              "node_modules",
              "site-packages",
              "venv",
          }

          def is_excluded(target: Path) -> bool:
              return any(part in excluded for part in target.parts)

          def iter_requirement_files(root: Path) -> Iterable[Path]:
              for current_root, dirnames, filenames in os.walk(root):
                  current_path = Path(current_root)
                  if is_excluded(current_path):
                      dirnames[:] = []
                      continue
                  dirnames[:] = sorted(
                      dirname
                      for dirname in dirnames
                      if not is_excluded(current_path / dirname)
                  )
                  for filename in filenames:
                      name_lower = filename.lower()
                      if not any(
                          fnmatch.fnmatch(filename, pattern)
                          or fnmatch.fnmatch(name_lower, pattern)
                          for pattern in patterns
                      ):
                          continue
                      yield current_path / filename

          for path in iter_requirement_files(Path(".")):
              try:
                  original = path.read_text(encoding="utf-8")
              except UnicodeDecodeError as exc:
                  print(
                      f"Skipping {path} due to encoding error: {exc}",
                      flush=True,
                  )
                  continue
              except OSError as exc:
                  print(
                      f"Skipping {path} due to filesystem error: {exc}",
                      flush=True,
                  )
                  continue
              lines = original.splitlines(keepends=True)
              filtered: list[str] = []
              for line in lines:
                  stripped = line.lstrip()
                  stripped_lower = stripped.lower()
                  if stripped_lower.startswith("ccxtpro"):
                      continue
                  if stripped_lower.startswith("#") and "ccxtpro" in stripped_lower:
                      continue
                  filtered.append(line)
              if filtered != lines:
                  updated = "".join(filtered)
                  try:
                      path.write_text(updated, encoding="utf-8")
                  except OSError as exc:
                      print(
                          f"::warning::Unable to update {path}: {exc}",
                          flush=True,
                      )
          PY
      - name: Submit dependency snapshot
        if: >-
          steps.detect.outputs.changed == 'true' ||
          github.event_name == 'workflow_dispatch' ||
          github.event_name == 'repository_dispatch' ||
          github.event_name == 'dependency_graph'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: python scripts/submit_dependency_snapshot.py
