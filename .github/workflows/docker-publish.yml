---
# yamllint disable rule:line-length rule:truthy
name: Build and Push Docker image
permissions:
  contents: read
  packages: write
  actions: write

on:
  push:
    branches: ["main", "master"]
  schedule:
    - cron: '0 0 * * 0'
  workflow_dispatch:

concurrency:
  group: docker-publish-${{ github.head_ref || github.ref_name || github.run_id }}
  cancel-in-progress: true

jobs:
  build:
    env:
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
      PUBLISH_IMAGES: >-
        ${{ github.repository == 'averinaleks/bot'
           && github.event_name != 'pull_request'
           && github.event_name != 'pull_request_target' }}
      PUBLISH_DOCKERHUB: >-
        ${{ github.repository == 'averinaleks/bot'
           && github.event_name != 'pull_request'
           && github.event_name != 'pull_request_target'
           && secrets.DOCKERHUB_USERNAME != ''
           && secrets.DOCKERHUB_USERNAME != null
           && secrets.DOCKERHUB_TOKEN != ''
           && secrets.DOCKERHUB_TOKEN != null }}
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        include:
          - file: Dockerfile.cpu
            image: bot-cpu
            artifact: trivy-report-cpu
          - file: Dockerfile.ci
            image: bot-ci
            artifact: trivy-report-ci
          - file: Dockerfile.gptoss
            image: bot-gptoss
            artifact: trivy-report-gptoss

    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5
        with:
          persist-credentials: false
      - name: Free disk space
        shell: bash
        run: |
          set -euxo pipefail

          # Отключаем и удаляем swap, чтобы избежать переполнения buildx при
          # выделении временных LVM-томов в maximize-build-space.
          if sudo swapon --summary | grep -q .; then
            sudo swapoff -a || true
          fi
          sudo rm -f /swapfile || true

          # Чистим предустановленные SDK и кэши, которые занимают десятки
          # гигабайт и не используются при сборке Docker-образов.
          sudo rm -rf \
            /usr/local/lib/android \
            /usr/local/share/boost \
            /usr/share/dotnet \
            /usr/lib/google-cloud-sdk \
            /opt/ghc \
            /opt/hostedtoolcache || true

          if [[ -n "${AGENT_TOOLSDIRECTORY:-}" && -d "${AGENT_TOOLSDIRECTORY}" ]]; then
            sudo rm -rf "${AGENT_TOOLSDIRECTORY}" || true
          fi

          # Убираем остатки кэшей APT и докера. Эти команды не являются
          # критичными, поэтому выполняем их в best-effort режиме.
          sudo apt-get clean || true
          sudo rm -rf /var/lib/apt/lists/* || true
          sudo docker system prune -af || true

          # Показываем итоговое свободное место для быстрой диагностики.
          df -h /
      - name: Prepare build mount dir
        run: |
          set -euo pipefail
          sudo mkdir -p /mnt
          if [ -e /dev/buildvg/buildlv ]; then
            sudo wipefs -a /dev/buildvg/buildlv || true
          else
            echo "Device /dev/buildvg/buildlv not found, skipping wipefs"
          fi
          sudo swapoff /mnt/swapfile || true
          sudo rm -f /mnt/swapfile || true
          sudo rm -rf /mnt/* || true
      - name: Install LVM
        run: sudo apt-get update && sudo apt-get install -y lvm2
      - name: Maximize build space
        uses: easimon/maximize-build-space@fc881a613ad2a34aca9c9624518214ebc21dfc0c  # v10
        with:
          root-reserve-mb: 8192
          temp-reserve-mb: 100
          swap-size-mb: 4096
          build-mount-path: /mnt
          pv-loop-path: /mnt/root-pv.img
          tmp-pv-loop-path: /mnt/tmp-pv.img

      - name: Verify root and /mnt free space
        run: |
          set -euo pipefail
          df -h /
          df -h /mnt

      - name: Relocate Docker storage to /mnt
        run: |
          set -euo pipefail
          if command -v systemctl >/dev/null; then
            sudo systemctl stop docker || true
          else
            sudo service docker stop || true
          fi
          sudo mv /var/lib/docker /mnt/docker || true
          sudo ln -sfn /mnt/docker /var/lib/docker
          if command -v systemctl >/dev/null; then
            sudo systemctl start docker
          else
            sudo service docker start
          fi

      - name: Wait for Docker daemon
        run: |
          set -euo pipefail
          for attempt in $(seq 1 30); do
            if docker info >/dev/null 2>&1 || sudo docker info >/dev/null 2>&1; then
              exit 0
            fi
            sleep 2
          done
          docker info

      - name: Set up Buildx
        id: buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3
        with:
          driver: docker-container
          # Обновляем buildx до актуальной версии, поддерживающей экспериментальный
          # фронтенд Dockerfile ``docker/dockerfile:1.7-labs`` и исправляющей
          # парсер, который ранее падал с "dockerfile parse error" на первом
          # шаге сборки. Одновременно обновляем buildkit до последнего стабильного
          # образа, чтобы сохранить совместимость с OCI-манифестами и кэшированием
          # через GitHub Actions.
          version: v0.29.1
          driver-opts: |
            image=moby/buildkit:v0.25.1

      - name: Show Buildx version
        run: docker buildx version

      - name: Verify /mnt mount
        run: |
          mount | grep '/mnt' || true
          df -h /mnt

      - name: Purge stale BuildKit cache
        if: ${{ env.PUBLISH_IMAGES == 'true' }}
        env:
          CACHE_SCOPE: ${{ matrix.image }}-oci-v4
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          ensure_jq() {
            if command -v jq >/dev/null 2>&1; then
              return 0
            fi

            if ! command -v apt-get >/dev/null 2>&1; then
              echo "::warning::jq is unavailable and cannot be installed; skipping cache purge"
              return 1
            fi

            echo "jq not found on runner, installing"
            sudo apt-get update -y >/dev/null
            sudo apt-get install -y jq >/dev/null
          }

          if ! ensure_jq; then
            exit 0
          fi

          api_url="https://api.github.com/repos/${{ github.repository }}/actions/caches?key=${CACHE_SCOPE}"
          response_file=$(mktemp -t cache-response.XXXXXX)
          trap 'rm -f "${response_file}"' EXIT

          status_code=$(curl -sS -w '%{http_code}' \
            -H 'Accept: application/vnd.github+json' \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -o "${response_file}" \
            "${api_url}")

          if [ "${status_code}" -ne 200 ]; then
            echo "::warning::Unable to query GitHub Actions cache API (status ${status_code})"
            cat "${response_file}" || true
            exit 0
          fi

          total=$(jq -r '.total_count // 0' "${response_file}" 2>/dev/null || echo 0)
          if [ "${total}" -le 0 ]; then
            echo "No cache entries found for scope ${CACHE_SCOPE}"
            exit 0
          fi

          echo "Found ${total} stale cache entr(ies) for scope ${CACHE_SCOPE}, deleting"
          delete_code=$(curl -sS -w '%{http_code}' \
            -H 'Accept: application/vnd.github+json' \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -o /dev/null \
            -X DELETE \
            "${api_url}")

          if [ "${delete_code}" -ge 200 ] && [ "${delete_code}" -lt 300 ]; then
            echo "Cache scope ${CACHE_SCOPE} successfully purged"
          else
            echo "::warning::Failed to delete cache scope ${CACHE_SCOPE} (status ${delete_code})"
          fi

      - name: Login to Docker Hub
        if: ${{ env.PUBLISH_DOCKERHUB == 'true' }}
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3
        with:
          username: ${{ env.DOCKERHUB_USERNAME }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: Login to GHCR
        if: ${{ env.PUBLISH_IMAGES == 'true' }}
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare image tags
        id: tags
        env:
          MATRIX_IMAGE: ${{ matrix.image }}
          OWNER: ${{ github.repository_owner }}
        run: |
          set -euo pipefail
          if [[ "${PUBLISH_IMAGES}" == "true" ]]; then
            tags="ghcr.io/${OWNER}/${MATRIX_IMAGE}:latest"
            if [[ -n "${DOCKERHUB_USERNAME}" && -n "${DOCKERHUB_TOKEN}" ]]; then
              tags="${tags}"$'\n'"docker.io/${DOCKERHUB_USERNAME}/${MATRIX_IMAGE}:latest"
            fi
          else
            tags="local/${MATRIX_IMAGE}:ci-${GITHUB_RUN_ID}"
          fi
          {
            echo "list<<EOF"
            echo "${tags}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      # Собираем образ напрямую через docker buildx CLI, чтобы можно было
      # перехватить типичную ошибку GitHub Actions Cache (HTML-ответ 400) и
      # выполнить повтор без кэшей. build-push-action не позволяет надёжно
      # переиспользовать ``continue-on-error`` для сохранения успешного статуса
      # job после такого сбоя, поэтому fallback реализован вручную.
      - name: Build and push Docker image
        id: build
        env:
          BUILDER_NAME: ${{ steps.buildx.outputs.name }}
          CACHE_SCOPE: ${{ matrix.image }}-oci-v4
          DOCKERFILE_PATH: ${{ matrix.file }}
          IMAGE_TAGS: ${{ steps.tags.outputs.list }}
          SHOULD_PUSH: ${{ env.PUBLISH_IMAGES }}
          MATRIX_IMAGE: ${{ matrix.image }}
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${IMAGE_TAGS}" ]; then
            echo "::error::Не удалось подготовить теги Docker-образа"
            exit 1
          fi

          mapfile -t ALL_IMAGE_TAGS < <(printf '%s\n' "${IMAGE_TAGS}" | tr -d '\r' | sed '/^$/d')

          if [ "${#ALL_IMAGE_TAGS[@]}" -eq 0 ]; then
            echo "::error::Не удалось подготовить теги Docker-образа"
            exit 1
          fi

          DOCKERHUB_TAGS=()
          for tag in "${ALL_IMAGE_TAGS[@]}"; do
            if [[ "${tag}" == docker.io/* ]]; then
              DOCKERHUB_TAGS+=("${tag}")
            fi
          done

          run_build() {
            local use_cache="$1"
            local push_mode="$2"
            shift 2
            local tags=("$@")

            local args=(--progress plain --file "${DOCKERFILE_PATH}")
            if [ -n "${BUILDER_NAME}" ]; then
              args+=(--builder "${BUILDER_NAME}")
            fi

            case "${push_mode}" in
              auto)
                if [ "${SHOULD_PUSH}" = "true" ]; then
                  args+=(--push)
                else
                  args+=(--load)
                fi
                ;;
              push)
                args+=(--push)
                ;;
              local)
                args+=(--load)
                ;;
              *)
                echo "::error::Unknown push mode: ${push_mode}"
                return 2
                ;;
            esac

            if [ "${#tags[@]}" -gt 0 ]; then
              for image_tag in "${tags[@]}"; do
                args+=(--tag "${image_tag}")
              done
            elif [ "${push_mode}" != "local" ] && [ "${SHOULD_PUSH}" = "true" ]; then
              echo "::error::No image tags available for docker build push"
              return 2
            fi

            if [ "${use_cache}" = "true" ]; then
              args+=(--cache-from "type=gha,scope=${CACHE_SCOPE},ignore-error=true")
              args+=(--cache-to "type=gha,scope=${CACHE_SCOPE},mode=max,ignore-error=true")
            else
              args+=(--no-cache)
            fi

            args+=(.)

            local log_file
            log_file=$(mktemp -t buildx-log.XXXXXX)

            docker buildx build "${args[@]}" |& tee "${log_file}"
            local status=${PIPESTATUS[0]}
            BUILD_LOG="${log_file}"
            return "${status}"
          }

          detect_ghcr_outage() {
            local log_file="$1"
            if [ ! -f "${log_file}" ]; then
              return 1
            fi

            # GHCR периодически отвечает HTML-страницами или ошибками 5xx.
            # Распознаём такие ответы, чтобы включить fallback на Docker Hub
            # или локальную сборку и избежать ложных падений workflow.
            local -a generic_patterns=(
              "Our services aren't available right now"
              "invalid character '<' looking for beginning of value"
              "<!DOCTYPE html>"
              "502 Bad Gateway"
              "503 Service"
              "504 Gateway"
              "500 Internal Server Error"
              "unexpected status code 5"
              "received unexpected HTTP status: 5"
            )

            for pattern in "${generic_patterns[@]}"; do
              if grep -Fqi "${pattern}" "${log_file}"; then
                return 0
              fi
            done

            if grep -Fqi 'ghcr.io' "${log_file}"; then
              local -a ghcr_network_patterns=(
                "connection reset by peer"
                "context deadline exceeded"
                "i/o timeout"
                "TLS handshake timeout"
              )
              # GHCR также может отвечать 4xx-статусами с HTML/текстом вместо JSON,
              # когда сервис авторизации недоступен. В таких случаях buildx
              # завершается с сообщениями о ``unexpected status code 40x`` или
              # ``error parsing HTTP 403 response body``. Распознаём эти ошибки
              # и обрабатываем их как временный сбой GHCR.
              local -a ghcr_http_patterns=(
                "error parsing HTTP 40"
                "unexpected status code 40"
                "unexpected status code: 40"
                "HTTP status: 401"
                "HTTP status: 403"
                "HTTP status: 429"
                "response status: 401"
                "response status: 403"
                "response status: 429"
                "error fetching anonymous token"
                "token exchange is currently unavailable"
                "TOOMANYREQUESTS"
                "Too Many Requests"
              )
              for pattern in "${ghcr_network_patterns[@]}"; do
                if grep -Fqi "${pattern}" "${log_file}"; then
                  return 0
                fi
              done
              for pattern in "${ghcr_http_patterns[@]}"; do
                if grep -Fqi "${pattern}" "${log_file}"; then
                  return 0
                fi
              done
            fi

            return 1
          }

          ghcr_outage="false"

          set +e
          run_build true auto "${ALL_IMAGE_TAGS[@]}"
          status=$?
          first_log="${BUILD_LOG}"
          set -e

          if [ "${status}" -eq 0 ]; then
            rm -f "${first_log}"
            echo "status=success" >> "${GITHUB_OUTPUT}"
            exit 0
          fi

          if detect_ghcr_outage "${first_log}"; then
            ghcr_outage="true"
            echo "::warning::GHCR responded with an HTML error during docker build (cache enabled)"
          else
            echo "::warning::docker buildx with GitHub Actions cache failed (exit code ${status}), retrying without cache"
          fi

          set +e
          run_build false auto "${ALL_IMAGE_TAGS[@]}"
          retry_status=$?
          second_log="${BUILD_LOG}"
          set -e

          if [ "${retry_status}" -eq 0 ]; then
            rm -f "${first_log}" "${second_log}"
            echo "status=success" >> "${GITHUB_OUTPUT}"
            exit 0
          fi

          if detect_ghcr_outage "${second_log}"; then
            ghcr_outage="true"
            echo "::warning::GHCR responded with an HTML error during docker build (cache disabled)"
          fi

          if [ "${ghcr_outage}" = "true" ] && [ "${SHOULD_PUSH}" = "true" ]; then
            if [ "${#DOCKERHUB_TAGS[@]}" -gt 0 ]; then
              echo "::warning::Retrying docker build with Docker Hub tags only due to GHCR outage"
              set +e
              run_build false auto "${DOCKERHUB_TAGS[@]}"
              dockerhub_status=$?
              dockerhub_log="${BUILD_LOG}"
              set -e
              if [ "${dockerhub_status}" -eq 0 ]; then
                rm -f "${first_log}" "${second_log}" "${dockerhub_log}"
                echo "::notice::GHCR push skipped; Docker Hub image updated successfully"
                echo "status=success" >> "${GITHUB_OUTPUT}"
                exit 0
              fi
              rm -f "${dockerhub_log}"
            fi

            echo "::warning::Skipping registry push due to GHCR outage; building image locally for verification"
            set +e
            local_fallback_tag="local/${MATRIX_IMAGE}:ghcr-outage-${GITHUB_RUN_ID}"
            local_tags=()
            for image_tag in "${ALL_IMAGE_TAGS[@]}"; do
              if [[ "${image_tag}" == ghcr.io/* ]]; then
                continue
              fi
              local_tags+=("${image_tag}")
            done

            if [ "${#local_tags[@]}" -eq 0 ]; then
              local_tags=("${local_fallback_tag}")
            fi

            primary_local_tag="${local_tags[0]}"
            local_log=$(mktemp -t docker-build-log.XXXXXX)
            docker build --file "${DOCKERFILE_PATH}" --tag "${primary_local_tag}" . |& tee "${local_log}"
            local_status=${PIPESTATUS[0]}

            if [ "${local_status}" -eq 0 ] && [ "${#local_tags[@]}" -gt 1 ]; then
              for extra_tag in "${local_tags[@]:1}"; do
                docker tag "${primary_local_tag}" "${extra_tag}" || local_status=$?
              done
            fi

            local_log_path="${local_log}"
            set -e
            if [ "${local_status}" -eq 0 ]; then
              rm -f "${first_log}" "${second_log}" "${local_log_path}"
              printf -v rendered_tags '%s, ' "${local_tags[@]}"
              rendered_tags=${rendered_tags%, }
              echo "::notice::Docker image built locally under tag(s) ${rendered_tags} because GHCR was unavailable"
              echo "status=success" >> "${GITHUB_OUTPUT}"
              exit 0
            fi
            rm -f "${local_log_path}"
          fi

          echo "::error::Docker build failed even after retry without cache (exit code ${retry_status})"
          if [ -f "${second_log}" ]; then
            tail -n 50 "${second_log}" || true
          fi
          rm -f "${first_log}" "${second_log}"
          exit "${retry_status}"

      - name: Cleanup before Trivy scan
        if: ${{ env.PUBLISH_DOCKERHUB == 'true' && steps.build.outputs.status == 'success' }}
        run: |
          sudo find /tmp -maxdepth 1 -name 'trivy-*' -exec rm -rf {} + || true
          sudo rm -rf /mnt/trivy-cache /mnt/trivy-tmp || true
          rm -rf ~/.cache/trivy || true
          sudo mkdir -p /mnt/trivy-cache
          sudo chown "$(id -u):$(id -g)" /mnt/trivy-cache
      - name: Prepare Trivy temp
        if: ${{ env.PUBLISH_DOCKERHUB == 'true' && steps.build.outputs.status == 'success' }}
        run: |
          sudo mkdir -p /mnt/trivy-tmp
          sudo chown "$(id -u):$(id -g)" /mnt/trivy-tmp
      - name: Run Trivy vulnerability scanner
        if: ${{ env.PUBLISH_DOCKERHUB == 'true' && steps.build.outputs.status == 'success' }}
        id: trivy
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8  # 0.33.1
        continue-on-error: true
        env:
          TMPDIR: /mnt/trivy-tmp
          TRIVY_CACHE_DIR: /mnt/trivy-cache
        with:
          version: v0.65.0
          image-ref: docker.io/${{ env.DOCKERHUB_USERNAME }}/${{ matrix.image }}:latest
          format: table
          output: ${{ matrix.artifact }}.txt
          scanners: vuln
      - name: Show Trivy scan results
        if: ${{ env.PUBLISH_DOCKERHUB == 'true' && steps.build.outputs.status == 'success' && contains(fromJSON('["success","failure"]'), steps.trivy.outcome) }}
        run: cat ${{ matrix.artifact }}.txt

      - name: Upload Trivy report artifact
        if: ${{ env.PUBLISH_DOCKERHUB == 'true' && steps.build.outputs.status == 'success' && contains(fromJSON('["success","failure"]'), steps.trivy.outcome) }}
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4  # v4
        with:
          name: ${{ matrix.artifact }}
          path: ${{ matrix.artifact }}.txt
      - name: Cleanup Docker
        if: ${{ always() }}
        run: |
          docker buildx prune -af || true
          docker system prune -af || true

  healthcheck:
    needs: build
    if: ${{ needs.build.result == 'success' }}
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5
        with:
          persist-credentials: false
      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c  # v6
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: python -m pip install -r requirements-healthcheck.txt
      - name: Start data handler service
        id: start_service
        env:
          TEST_MODE: "1"
          DATA_HANDLER_ALLOW_ANONYMOUS: "1"
          DATA_HANDLER_USE_STUB: "1"
        run: |
          scripts/run_data_handler_service.sh --bind 0.0.0.0:8000 &
          echo $! > "$GITHUB_WORKSPACE/service.pid"
          sleep 5
          if ! kill -0 "$(cat "$GITHUB_WORKSPACE/service.pid")" 2>/dev/null; then
            echo "service_running=false" >> "$GITHUB_OUTPUT"
          else
            echo "service_running=true" >> "$GITHUB_OUTPUT"
          fi
      - name: Health check
        if: ${{ steps.start_service.outputs.service_running == 'true' }}
        env:
          TEST_MODE: "1"
          HEALTH_CHECK_MAX_ATTEMPTS: "10"
          HEALTH_CHECK_DELAY_SECONDS: "3"
          HEALTH_CHECK_BASE_URL: "http://127.0.0.1:8000"
          HEALTH_CHECK_ALLOWED_HOSTS: "localhost,127.0.0.1,::1"
          DATA_HANDLER_USE_STUB: "1"
          TRADE_MANAGER_TOKEN: "dummy-token"
          TRADE_RISK_USD: "0"
        run: python scripts/health_check.py
      - name: Cleanup
        if: ${{ always() && steps.start_service.outputs.service_running == 'true' }}
        run: |
          kill "$(cat "$GITHUB_WORKSPACE/service.pid")" || true
          rm -f "$GITHUB_WORKSPACE/service.pid"
