---
# yamllint disable rule:line-length rule:truthy
name: Build and Push Docker image
permissions:
  contents: read
  packages: write
  actions: write

on:
  push:
    branches: ["main", "master"]
  schedule:
    - cron: '0 0 * * 0'
  workflow_dispatch:

concurrency:
  group: docker-publish-${{ github.head_ref || github.ref_name || github.run_id }}
  cancel-in-progress: true

jobs:
  build:
    env:
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
      PUBLISH_IMAGES: >-
        ${{ github.repository == 'averinaleks/bot'
           && github.event_name != 'pull_request'
           && github.event_name != 'pull_request_target'
           && 'true'
           || 'false' }}
      PUBLISH_DOCKERHUB: >-
        ${{ github.repository == 'averinaleks/bot'
           && github.event_name != 'pull_request'
           && github.event_name != 'pull_request_target'
           && secrets.DOCKERHUB_USERNAME != ''
           && secrets.DOCKERHUB_USERNAME != null
           && secrets.DOCKERHUB_TOKEN != ''
           && secrets.DOCKERHUB_TOKEN != null
           && 'true'
           || 'false' }}
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        include:
          - file: Dockerfile.cpu
            image: bot-cpu
            artifact: trivy-report-cpu
          - file: Dockerfile.ci
            image: bot-ci
            artifact: trivy-report-ci
          - file: Dockerfile.gptoss
            image: bot-gptoss
            artifact: trivy-report-gptoss

    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v4
        with:
          persist-credentials: false
      - name: Free disk space
        shell: bash
        run: |
          set -euxo pipefail

          # Отключаем и удаляем swap, чтобы избежать переполнения buildx при
          # выделении временных LVM-томов в maximize-build-space.
          if sudo swapon --summary | grep -q .; then
            sudo swapoff -a || true
          fi
          sudo rm -f /swapfile || true

          # Чистим предустановленные SDK и кэши, которые занимают десятки
          # гигабайт и не используются при сборке Docker-образов.
          sudo rm -rf \
            /usr/local/lib/android \
            /usr/local/share/boost \
            /usr/share/dotnet \
            /usr/lib/google-cloud-sdk \
            /opt/ghc \
            /opt/hostedtoolcache || true

          # actions/tool-cache (используется setup-buildx-action) ожидает, что
          # $RUNNER_TOOL_CACHE доступен для записи текущему пользователю.
          # После очистки каталога пересоздаём его с правильными правами.
          sudo mkdir -p /opt/hostedtoolcache
          sudo chown "$(id -u):$(id -g)" /opt/hostedtoolcache

          if [[ -n "${AGENT_TOOLSDIRECTORY:-}" && -d "${AGENT_TOOLSDIRECTORY}" ]]; then
            sudo rm -rf "${AGENT_TOOLSDIRECTORY}" || true
            sudo mkdir -p "${AGENT_TOOLSDIRECTORY}"
            sudo chown "$(id -u):$(id -g)" "${AGENT_TOOLSDIRECTORY}"
          fi

          # Убираем остатки кэшей APT и докера. Эти команды не являются
          # критичными, поэтому выполняем их в best-effort режиме.
          sudo apt-get clean || true
          sudo rm -rf /var/lib/apt/lists/* || true
          sudo docker system prune -af || true

          # Показываем итоговое свободное место для быстрой диагностики.
          df -h /
      - name: Prepare build mount dir
        run: |
          set -euo pipefail
          sudo mkdir -p /mnt
          if [ -e /dev/buildvg/buildlv ]; then
            sudo wipefs -a /dev/buildvg/buildlv || true
          else
            echo "Device /dev/buildvg/buildlv not found, skipping wipefs"
          fi
          sudo swapoff /mnt/swapfile || true
          sudo rm -f /mnt/swapfile || true
          sudo rm -rf /mnt/* || true
      - name: Install LVM
        run: sudo apt-get update && sudo apt-get install -y lvm2
      - name: Maximize build space
        uses: easimon/maximize-build-space@fc881a613ad2a34aca9c9624518214ebc21dfc0c  # v10
        with:
          root-reserve-mb: 8192
          temp-reserve-mb: 100
          swap-size-mb: 4096
          build-mount-path: /mnt
          pv-loop-path: /mnt/root-pv.img
          tmp-pv-loop-path: /mnt/tmp-pv.img

      - name: Verify root and /mnt free space
        run: |
          set -euo pipefail
          df -h /
          df -h /mnt

      - name: Relocate Docker storage to /mnt
        run: |
          set -euo pipefail
          if command -v systemctl >/dev/null; then
            if ! sudo systemctl stop docker; then
              echo "systemctl stop docker failed, falling back to service command"
              sudo service docker stop || true
            fi
          else
            sudo service docker stop || true
          fi
          sudo mv /var/lib/docker /mnt/docker || true
          sudo ln -sfn /mnt/docker /var/lib/docker
          if command -v systemctl >/dev/null; then
            if ! sudo systemctl start docker; then
              echo "systemctl start docker failed, falling back to service command"
              sudo service docker start
            fi
          else
            sudo service docker start
          fi

      - name: Wait for Docker daemon
        run: |
          set -euo pipefail
          for _ in $(seq 1 30); do
            if docker info >/dev/null 2>&1 || sudo docker info >/dev/null 2>&1; then
              exit 0
            fi
            sleep 2
          done
          docker info

      - name: Normalize registry names
        id: normalize
        env:
          OWNER: ${{ github.repository_owner }}
          DOCKERHUB_USER: ${{ env.DOCKERHUB_USERNAME }}
        run: |
          set -euo pipefail
          normalize_name() {
            printf '%s' "$1" | tr '[:upper:]' '[:lower:]'
          }

          owner_normalized="$(normalize_name "${OWNER}")"
          dockerhub_normalized=""
          if [ -n "${DOCKERHUB_USER}" ]; then
            dockerhub_normalized="$(normalize_name "${DOCKERHUB_USER}")"
          fi

          {
            echo "REGISTRY_OWNER_NORMALIZED=${owner_normalized}"
            echo "DOCKERHUB_USERNAME_NORMALIZED=${dockerhub_normalized}"
          } >>"$GITHUB_ENV"

          {
            echo "owner=${owner_normalized}"
            echo "dockerhub=${dockerhub_normalized}"
          } >>"$GITHUB_OUTPUT"

      - name: Login to Docker Hub
        if: ${{ env.PUBLISH_DOCKERHUB == 'true' }}
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9  # v3
        with:
          username: ${{ env.DOCKERHUB_USERNAME_NORMALIZED }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: Prepare BuildKit image
        id: buildkit-image
        run: |
          set -euo pipefail

          primary_image="moby/buildkit:v0.12.5"
          fallback_image="ghcr.io/moby/buildkit:v0.12.5"

          pull_with_retry() {
            local image="$1"
            local attempt
            for attempt in 1 2 3; do
              echo "Pulling ${image} (attempt ${attempt})"
              if docker pull "${image}"; then
                return 0
              fi
              sleep $((attempt * 2))
            done
            return 1
          }

          if pull_with_retry "${primary_image}"; then
            echo "image=${primary_image}" >>"${GITHUB_OUTPUT}"
            exit 0
          fi

          echo "::warning::Failed to pull ${primary_image}; retrying with ${fallback_image}"
          if pull_with_retry "${fallback_image}"; then
            echo "image=${fallback_image}" >>"${GITHUB_OUTPUT}"
            exit 0
          fi

          echo "::error::Unable to pull BuildKit image from Docker Hub or GHCR"
          exit 1

      - name: Set up Buildx (primary)
        id: buildx_primary
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f  # v3
        continue-on-error: true
        with:
          driver: docker-container
          # Обновляем buildx до стабильной версии, поддерживающей экспериментальный
          # фронтенд Dockerfile ``docker/dockerfile:1.7-labs`` и исправляющей
          # парсер, который ранее падал с "dockerfile parse error" на первом
          # шаге сборки. Одновременно обновляем buildkit до последнего стабильного
          # образа, чтобы сохранить совместимость с OCI-манифестами и кэшированием
          # через GitHub Actions.
          version: v0.12.1
          driver-opts: |
            image=${{ steps.buildkit-image.outputs.image }}

      - name: Set up Buildx (fallback)
        id: buildx_fallback
        if: ${{ steps.buildx_primary.outcome == 'failure' }}
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f  # v3
        with:
          driver: docker-container
          # Fallback: используем встроенную в action версию buildx, если
          # закреплённая версия временно недоступна из-за сетевой ошибки.
          driver-opts: |
            image=${{ steps.buildkit-image.outputs.image }}

      - name: Validate Buildx setup
        if: ${{ steps.buildx_primary.outcome == 'failure' && steps.buildx_fallback.outcome != 'success' }}
        run: |
          echo "::error::Failed to initialize Buildx with both primary and fallback configuration"
          exit 1

      - name: Select active Buildx builder
        id: buildx
        run: |
          set -euo pipefail
          builder_name="${{ steps.buildx_primary.outputs.name }}"
          if [ -z "${builder_name}" ]; then
            builder_name="${{ steps.buildx_fallback.outputs.name }}"
          fi
          if [ -z "${builder_name}" ]; then
            echo "::error::Buildx builder name is empty"
            exit 1
          fi
          echo "name=${builder_name}" >>"${GITHUB_OUTPUT}"

      - name: Show Buildx version
        run: docker buildx version

      - name: Verify /mnt mount
        run: |
          mount | grep '/mnt' || true
          df -h /mnt

      - name: Purge stale BuildKit cache
        if: ${{ env.PUBLISH_IMAGES == 'true' }}
        env:
          CACHE_SCOPE: ${{ matrix.image }}-oci-v4
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          ensure_jq() {
            if command -v jq >/dev/null 2>&1; then
              return 0
            fi

            if ! command -v apt-get >/dev/null 2>&1; then
              echo "::warning::jq is unavailable and cannot be installed; skipping cache purge"
              return 1
            fi

            echo "jq not found on runner, installing"
            sudo apt-get update -y >/dev/null
            sudo apt-get install -y jq >/dev/null
          }

          if ! ensure_jq; then
            exit 0
          fi

          api_url="https://api.github.com/repos/${{ github.repository }}/actions/caches?key=${CACHE_SCOPE}"
          response_file=$(mktemp -t cache-response.XXXXXX)
          trap 'rm -f "${response_file}"' EXIT

          status_code=$(curl -sS -w '%{http_code}' \
            -H 'Accept: application/vnd.github+json' \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -o "${response_file}" \
            "${api_url}")

          if [ "${status_code}" -ne 200 ]; then
            echo "::warning::Unable to query GitHub Actions cache API (status ${status_code})"
            cat "${response_file}" || true
            exit 0
          fi

          total=$(jq -r '.total_count // 0' "${response_file}" 2>/dev/null || echo 0)
          if [ "${total}" -le 0 ]; then
            echo "No cache entries found for scope ${CACHE_SCOPE}"
            exit 0
          fi

          echo "Found ${total} stale cache entr(ies) for scope ${CACHE_SCOPE}, deleting"
          delete_code=$(curl -sS -w '%{http_code}' \
            -H 'Accept: application/vnd.github+json' \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -o /dev/null \
            -X DELETE \
            "${api_url}")

          if [ "${delete_code}" -ge 200 ] && [ "${delete_code}" -lt 300 ]; then
            echo "Cache scope ${CACHE_SCOPE} successfully purged"
          else
            echo "::warning::Failed to delete cache scope ${CACHE_SCOPE} (status ${delete_code})"
          fi

      - name: Login to GHCR
        if: ${{ env.PUBLISH_IMAGES == 'true' }}
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9  # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare image tags
        id: tags
        env:
          OWNER_FALLBACK: ${{ github.repository_owner }}
          OWNER_NORMALIZED: ${{ env.REGISTRY_OWNER_NORMALIZED }}
          DOCKERHUB_USER_NORMALIZED: ${{ env.DOCKERHUB_USERNAME_NORMALIZED }}
          MATRIX_IMAGE: ${{ matrix.image }}
        run: |
          set -euo pipefail
          normalize_name() {
            # Docker/OCI реестры требуют имена в нижнем регистре; GHCR и Docker Hub
            # завершаются с ``invalid reference format`` при наличии заглавных букв.
            printf '%s' "$1" | tr '[:upper:]' '[:lower:]'
          }

          owner_normalized="${OWNER_NORMALIZED:-}"
          dockerhub_user_normalized="${DOCKERHUB_USER_NORMALIZED:-}"
          if [[ -z "${owner_normalized}" ]]; then
            owner_normalized="$(normalize_name "${OWNER_FALLBACK}")"
          fi

          image_name_normalized="$(normalize_name "${MATRIX_IMAGE}")"

          if [[ "${PUBLISH_IMAGES}" == "true" ]]; then
            tags="ghcr.io/${owner_normalized}/${image_name_normalized}:latest"
            if [[ -n "${dockerhub_user_normalized}" && -n "${DOCKERHUB_TOKEN:-}" ]]; then
              tags="${tags}"$'\n'"docker.io/${dockerhub_user_normalized}/${image_name_normalized}:latest"
            fi
          else
            tags="local/${image_name_normalized}:ci-${GITHUB_RUN_ID}"
          fi
          {
            echo "list<<EOF"
            echo "${tags}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      # Собираем образ напрямую через docker buildx CLI, чтобы можно было
      # перехватить типичную ошибку GitHub Actions Cache (HTML-ответ 400) и
      # выполнить повтор без кэшей. build-push-action не позволяет надёжно
      # переиспользовать ``continue-on-error`` для сохранения успешного статуса
      # job после такого сбоя, поэтому fallback реализован вручную.
      - name: Build and push Docker image
        id: build
        env:
          BUILDER_NAME: ${{ steps.buildx.outputs.name }}
          CACHE_SCOPE: ${{ matrix.image }}-oci-v4
          DOCKERFILE_PATH: ${{ matrix.file }}
          IMAGE_TAGS: ${{ steps.tags.outputs.list }}
          SHOULD_PUSH: ${{ env.PUBLISH_IMAGES }}
          MATRIX_IMAGE: ${{ matrix.image }}
        shell: bash
        run: |
          set -euo pipefail
          # Защищаемся от history expansion (``!DOCTYPE`` и т.п.) в bash.
          set +H

          LOG_BASE_DIR="${RUNNER_TEMP:-/tmp}/docker-build-logs/${MATRIX_IMAGE}"
          rm -rf "${LOG_BASE_DIR}"
          mkdir -p "${LOG_BASE_DIR}"
          log_index=0

          archive_build_log() {
            local source="$1"
            local label="$2"

            if [ ! -f "${source}" ]; then
              return 0
            fi

            log_index=$((log_index + 1))
            local dest_index
            printf -v dest_index '%02d' "${log_index}"
            local dest="${LOG_BASE_DIR}/${dest_index}-${label}.log"

            if ! cp "${source}" "${dest}" 2>/dev/null; then
              cat "${source}" >"${dest}"
            fi

            echo "${dest}"
          }

          if [ -z "${IMAGE_TAGS}" ]; then
            echo "::error::Не удалось подготовить теги Docker-образа"
            exit 1
          fi

          mapfile -t ALL_IMAGE_TAGS < <(printf '%s\n' "${IMAGE_TAGS}" | tr -d '\r' | sed '/^$/d')

          if [ "${#ALL_IMAGE_TAGS[@]}" -eq 0 ]; then
            echo "::error::Не удалось подготовить теги Docker-образа"
            exit 1
          fi

          CURRENT_IMAGE_TAGS=("${ALL_IMAGE_TAGS[@]}")
          DOCKERHUB_TAGS=()
          GHCR_TAGS=()
          NON_GHCR_TAGS=()
          for tag in "${ALL_IMAGE_TAGS[@]}"; do
            if [[ "${tag}" == ghcr.io/* ]]; then
              GHCR_TAGS+=("${tag}")
            else
              NON_GHCR_TAGS+=("${tag}")
            fi

            if [[ "${tag}" == docker.io/* ]]; then
              DOCKERHUB_TAGS+=("${tag}")
            fi
          done
          ORIGINAL_GHCR_TAGS=("${GHCR_TAGS[@]}")

          disable_ghcr_tags() {
            if [ "${#ORIGINAL_GHCR_TAGS[@]}" -eq 0 ]; then
              return 1
            fi

            if [ "${#NON_GHCR_TAGS[@]}" -eq 0 ]; then
              local fallback_tag="local/${MATRIX_IMAGE}:ghcr-outage-${GITHUB_RUN_ID}"
              NON_GHCR_TAGS=("${fallback_tag}")
              ghcr_local_only="true"
            else
              ghcr_local_only="false"
            fi

            CURRENT_IMAGE_TAGS=("${NON_GHCR_TAGS[@]}")
            return 0
          }

          run_build() {
            local use_cache="$1"
            local push_mode="$2"
            shift 2
            local tags=("$@")

            # Always refresh base layers to avoid intermittent build failures
            # when upstream images are removed or replaced. Without ``--pull``
            # BuildKit can occasionally stop early with obscure resolver
            # errors, which then aborts the whole publish job.
            local args=(--progress plain --file "${DOCKERFILE_PATH}" --pull)
            if [ -n "${BUILDER_NAME}" ]; then
              args+=(--builder "${BUILDER_NAME}")
            fi

            case "${push_mode}" in
              auto)
                if [ "${SHOULD_PUSH}" = "true" ]; then
                  args+=(--push)
                else
                  args+=(--load)
                fi
                ;;
              push)
                args+=(--push)
                ;;
              local)
                args+=(--load)
                ;;
              *)
                echo "::error::Unknown push mode: ${push_mode}"
                return 2
                ;;
            esac

            if [ "${#tags[@]}" -gt 0 ]; then
              for image_tag in "${tags[@]}"; do
                args+=(--tag "${image_tag}")
              done
            elif [ "${push_mode}" != "local" ] && [ "${SHOULD_PUSH}" = "true" ]; then
              echo "::error::No image tags available for docker build push"
              return 2
            fi

            if [ "${use_cache}" = "true" ]; then
              args+=(--cache-from "type=gha,scope=${CACHE_SCOPE},ignore-error=true")
              args+=(--cache-to "type=gha,scope=${CACHE_SCOPE},mode=max,ignore-error=true")
            else
              args+=(--no-cache)
            fi

            args+=(.)

            local log_file
            log_file=$(mktemp -t buildx-log.XXXXXX)

            docker buildx build "${args[@]}" |& tee "${log_file}"
            local status=${PIPESTATUS[0]}
            BUILD_LOG="${log_file}"
            archive_build_log "${log_file}" "build-${use_cache}-${push_mode}"
            return "${status}"
          }

          detect_ghcr_outage() {
            local log_file="$1"
            if [ ! -f "${log_file}" ]; then
              return 1
            fi

            # GHCR периодически отвечает HTML-страницами, ошибками 5xx или
            # банальными сетевыми сбоями DNS/handshake. Распознаём такие
            # ответы, чтобы включить fallback на Docker Hub или локальную
            # сборку и избежать ложных падений workflow.
            local -a generic_patterns=(
              "Our services aren't available right now"
              "failed to parse error response 400"
              "invalid character '<' looking for beginning of value"
              "<!DOCTYPE html>"
              "502 Bad Gateway"
              "503 Service"
              "504 Gateway"
              "500 Internal Server Error"
              "unexpected status code 5"
              "received unexpected HTTP status: 5"
            )

            for pattern in "${generic_patterns[@]}"; do
              if grep -Fqi "${pattern}" "${log_file}"; then
                return 0
              fi
            done

            if grep -Fqi 'ghcr.io' "${log_file}"; then
              local -a ghcr_network_patterns=(
                "connection reset by peer"
                "context deadline exceeded"
                "i/o timeout"
                "TLS handshake timeout"
                "lookup ghcr.io"
                "no such host"
                "Name or service not known"
                "temporary failure in name resolution"
              )
              # GHCR также может отвечать 4xx-статусами с HTML/текстом вместо JSON,
              # когда сервис авторизации недоступен. В таких случаях buildx
              # завершается с сообщениями о ``unexpected status code 40x`` или
              # ``error parsing HTTP 403 response body``. Распознаём эти ошибки
              # и обрабатываем их как временный сбой GHCR.
              local -a ghcr_http_patterns=(
                "error parsing HTTP 40"
                "unexpected status code 40"
                "unexpected status code: 40"
                "HTTP status: 401"
                "HTTP status: 403"
                "HTTP status: 429"
                "response status: 401"
                "response status: 403"
                "response status: 429"
                "denied: requested access to the resource is denied"
                "requested access to the resource is denied"
                "denied: permission denied"
                "permission denied"
                "MANIFEST_UNKNOWN"
                "NAME_UNKNOWN"
                "unauthorized: authentication required"
                "unauthorized: access to the requested resource is denied"
                "UNAUTHORIZED"
                "insufficient_scope: authorization failed"
                "error fetching anonymous token"
                "token exchange is currently unavailable"
                "TOOMANYREQUESTS"
                "Too Many Requests"
              )
              for pattern in "${ghcr_network_patterns[@]}"; do
                if grep -Fqi "${pattern}" "${log_file}"; then
                  return 0
                fi
              done
              for pattern in "${ghcr_http_patterns[@]}"; do
                if grep -Fqi "${pattern}" "${log_file}"; then
                  return 0
                fi
              done
            fi

            return 1
          }

          handle_ghcr_outage() {
            local log_file="$1"
            local stage="$2"

            if ! detect_ghcr_outage "${log_file}"; then
              return 1
            fi

            echo "::warning::GHCR responded with an HTML error during docker build (${stage})"

            if [ "${ghcr_tags_disabled}" != "true" ] && disable_ghcr_tags; then
              ghcr_tags_disabled="true"
              if [ "${#ORIGINAL_GHCR_TAGS[@]}" -gt 0 ]; then
                printf -v skipped_tags '%s, ' "${ORIGINAL_GHCR_TAGS[@]}"
                skipped_tags=${skipped_tags%, }
                echo "::warning::Temporarily skipping GHCR tag(s): ${skipped_tags}"
              fi
            fi

            if [ "${SHOULD_PUSH}" = "true" ] && [ "${#DOCKERHUB_TAGS[@]}" -gt 0 ]; then
              echo "::warning::Retrying docker build with Docker Hub tags only due to GHCR outage (${stage})"
              set +e
              run_build false auto "${DOCKERHUB_TAGS[@]}"
              dockerhub_status=$?
              dockerhub_log="${BUILD_LOG}"
              set -e
              if [ "${dockerhub_status}" -eq 0 ]; then
                rm -f "${log_file}" "${dockerhub_log}"
                echo "::notice::GHCR push skipped; Docker Hub image updated successfully"
                echo "status=success" >> "${GITHUB_OUTPUT}"
                return 0
              fi
              rm -f "${dockerhub_log}" || true
            fi

            echo "::warning::Skipping registry push due to GHCR outage; building image locally for verification (${stage})"
            set +e
            local_fallback_tag="local/${MATRIX_IMAGE}:ghcr-outage-${GITHUB_RUN_ID}"
            local_tags=("${NON_GHCR_TAGS[@]}")
            if [ "${#local_tags[@]}" -eq 0 ]; then
              local_tags=("${local_fallback_tag}")
            fi
            primary_local_tag="${local_tags[0]}"
            local_log=$(mktemp -t docker-build-log.XXXXXX)
            docker build --file "${DOCKERFILE_PATH}" --tag "${primary_local_tag}" . |& tee "${local_log}"
            local_status=${PIPESTATUS[0]}
            archive_build_log "${local_log}" "local-fallback"

            if [ "${local_status}" -eq 0 ] && [ "${#local_tags[@]}" -gt 1 ]; then
              for extra_tag in "${local_tags[@]:1}"; do
                docker tag "${primary_local_tag}" "${extra_tag}" || local_status=$?
              done
            fi

            local_log_path="${local_log}"
            set -e
            if [ "${local_status}" -eq 0 ]; then
              rm -f "${log_file}" "${local_log_path}"
              printf -v rendered_tags '%s, ' "${local_tags[@]}"
              rendered_tags=${rendered_tags%, }
              echo "::notice::Docker image built locally under tag(s) ${rendered_tags} because GHCR was unavailable"
              echo "status=success" >> "${GITHUB_OUTPUT}"
              return 0
            fi

            rm -f "${local_log_path}" || true
            return 1
          }

          ghcr_tags_disabled="false"
          ghcr_local_only="false"

          set +e
          run_build true auto "${CURRENT_IMAGE_TAGS[@]}"
          status=$?
          first_log="${BUILD_LOG}"
          set -e

          if [ "${status}" -eq 0 ]; then
            rm -f "${first_log}"
            echo "status=success" >> "${GITHUB_OUTPUT}"
            exit 0
          fi

          if handle_ghcr_outage "${first_log}" "cache enabled"; then
            exit 0
          fi

          echo "::warning::docker buildx with GitHub Actions cache failed (exit code ${status}), retrying without cache"

          set +e
          retry_push_mode="auto"
          if [ "${ghcr_local_only}" = "true" ]; then
            retry_push_mode="local"
          fi

          run_build false "${retry_push_mode}" "${CURRENT_IMAGE_TAGS[@]}"
          retry_status=$?
          second_log="${BUILD_LOG}"
          set -e

          if [ "${retry_status}" -eq 0 ]; then
            rm -f "${first_log}" "${second_log}"
            if [ "${ghcr_tags_disabled}" = "true" ]; then
              if [ "${#CURRENT_IMAGE_TAGS[@]}" -gt 0 ]; then
                printf -v kept_tags '%s, ' "${CURRENT_IMAGE_TAGS[@]}"
                kept_tags=${kept_tags%, }
              else
                kept_tags="local/${MATRIX_IMAGE}:ghcr-outage-${GITHUB_RUN_ID}"
              fi
              echo "::notice::Docker image built without GHCR push due to outage; tag(s): ${kept_tags}"
            fi
            echo "status=success" >> "${GITHUB_OUTPUT}"
            exit 0
          fi

          if handle_ghcr_outage "${second_log}" "cache disabled"; then
            exit 0
          fi

          echo "::error::Docker build failed even after retry without cache (exit code ${retry_status})"
          if [ -f "${second_log}" ]; then
            tail -n 50 "${second_log}" || true
          fi
          rm -f "${first_log}" "${second_log}"
          exit "${retry_status}"

      - name: Upload Docker build logs
        if: ${{ failure() }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v4
        with:
          name: docker-build-logs-${{ matrix.image }}
          path: ${{ runner.temp }}/docker-build-logs/${{ matrix.image }}
          if-no-files-found: ignore

      - name: Cleanup before Trivy scan
        if: ${{ env.PUBLISH_DOCKERHUB == 'true' && steps.build.outputs.status == 'success' }}
        run: |
          sudo find /tmp -maxdepth 1 -name 'trivy-*' -exec rm -rf {} + || true
          sudo rm -rf /mnt/trivy-cache /mnt/trivy-tmp || true
          rm -rf ~/.cache/trivy || true
          sudo mkdir -p /mnt/trivy-cache
          sudo chown "$(id -u):$(id -g)" /mnt/trivy-cache
      - name: Prepare Trivy temp
        if: ${{ env.PUBLISH_DOCKERHUB == 'true' && steps.build.outputs.status == 'success' }}
        run: |
          sudo mkdir -p /mnt/trivy-tmp
          sudo chown "$(id -u):$(id -g)" /mnt/trivy-tmp
      - name: Run Trivy vulnerability scanner
        if: ${{ env.PUBLISH_DOCKERHUB == 'true' && steps.build.outputs.status == 'success' }}
        id: trivy
        uses: aquasecurity/trivy-action@c1824fd6edce30d7ab345a9989de00bbd46ef284  # 0.34.0
        continue-on-error: true
        env:
          TMPDIR: /mnt/trivy-tmp
          TRIVY_CACHE_DIR: /mnt/trivy-cache
        with:
          version: v0.65.0
          image-ref: docker.io/${{ env.DOCKERHUB_USERNAME_NORMALIZED }}/${{ matrix.image }}:latest
          format: table
          output: ${{ matrix.artifact }}.txt
          scanners: vuln
      - name: Show Trivy scan results
        if: >-
          ${{ env.PUBLISH_DOCKERHUB == 'true' && steps.build.outputs.status == 'success'
              && (steps.trivy.outcome == 'success' || steps.trivy.outcome == 'failure') }}
        run: |
          # ``bash`` в GitHub Actions запускается с ``-e`` по умолчанию, из-за чего
          # отсутствие отчёта или пустой файл могло приводить к падению шага
          # ``Show Trivy scan results``. Снимаем ``errexit`` перед чтением отчёта,
          # чтобы выводить предупреждения без прерывания job.
          set +e
          set -u
          report="${{ matrix.artifact }}.txt"
          if [[ -r "${report}" ]]; then
            # ``cat`` может завершиться с ошибкой, если Trivy оставил пустой или
            # частично записанный файл. Поскольку этот шаг информационный,
            # выводим предупреждение, но не прерываем job.
            if ! cat "${report}"; then
              echo "::warning::Failed to read Trivy report ${report}"
            fi
          else
            echo "::warning::Trivy report ${report} is missing or unreadable"
          fi

      - name: Upload Trivy report artifact
        if: >-
          ${{ env.PUBLISH_DOCKERHUB == 'true' && steps.build.outputs.status == 'success'
              && (steps.trivy.outcome == 'success' || steps.trivy.outcome == 'failure') }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v4
        with:
          name: ${{ matrix.artifact }}
          path: ${{ matrix.artifact }}.txt
          if-no-files-found: warn
      - name: Cleanup Docker
        if: ${{ always() }}
        run: |
          docker buildx prune -af || true
          docker system prune -af || true

  healthcheck:
    needs: build
    if: ${{ needs.build.result == 'success' }}
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v4
        with:
          persist-credentials: false
      - name: Set up Python
        uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405  # v5
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: python -m pip install -r requirements-healthcheck.txt
      - name: Start data handler service
        id: start_service
        env:
          TEST_MODE: "1"
          DATA_HANDLER_ALLOW_ANONYMOUS: "1"
          DATA_HANDLER_USE_STUB: "1"
        run: |
          scripts/run_data_handler_service.sh --bind 0.0.0.0:8000 &
          echo $! > "$GITHUB_WORKSPACE/service.pid"
          sleep 5
          if ! kill -0 "$(cat "$GITHUB_WORKSPACE/service.pid")" 2>/dev/null; then
            echo "service_running=false" >> "$GITHUB_OUTPUT"
          else
            echo "service_running=true" >> "$GITHUB_OUTPUT"
          fi
      - name: Health check
        if: ${{ steps.start_service.outputs.service_running == 'true' }}
        env:
          TEST_MODE: "1"
          HEALTH_CHECK_MAX_ATTEMPTS: "10"
          HEALTH_CHECK_DELAY_SECONDS: "3"
          HEALTH_CHECK_BASE_URL: "http://127.0.0.1:8000"
          HEALTH_CHECK_ALLOWED_HOSTS: "localhost,127.0.0.1,::1"
          DATA_HANDLER_USE_STUB: "1"
          TRADE_MANAGER_TOKEN: "dummy-token"
          TRADE_RISK_USD: "0"
        run: python scripts/health_check.py
      - name: Cleanup
        if: ${{ always() && steps.start_service.outputs.service_running == 'true' }}
        run: |
          kill "$(cat "$GITHUB_WORKSPACE/service.pid")" || true
          rm -f "$GITHUB_WORKSPACE/service.pid"
