---
# yamllint disable rule:line-length
name: Dependabot Auto Merge

on:  # yamllint disable-line rule:truthy
  pull_request_target:
    types: [opened, reopened, synchronize]
  push:
    branches:
      - main
      - 'dependabot/**'

permissions:
  contents: write
  pull-requests: write

jobs:
  skip-non-dependabot:
    runs-on: ubuntu-latest
    env:
      IS_DEPENDABOT: ${{ github.actor == 'dependabot[bot]' || github.actor == 'dependabot-preview[bot]' }}
    steps:
      - name: Report skipped run
        if: ${{ github.event_name != 'pull_request_target' || env.IS_DEPENDABOT != 'true' }}
        run: |
          write_summary() {
            if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
              mkdir -p "$(dirname "$GITHUB_STEP_SUMMARY")"
              printf '%s\n' "$1" >>"$GITHUB_STEP_SUMMARY"
            else
              printf '%s\n' "$1"
            fi
          }

          write_summary "Dependabot automation runs only for Dependabot pull_request_target events."
          write_summary "Actor '${{ github.actor }}' on event '${{ github.event_name }}' does not require action."

  dependabot:
    if: >-
      ${{
        github.event_name == 'pull_request_target' &&
        (github.actor == 'dependabot[bot]' || github.actor == 'dependabot-preview[bot]') &&
        github.event.pull_request != null &&
        github.event.pull_request.head.repo.full_name == github.repository
      }}
    runs-on: ubuntu-latest
    steps:
      - name: Dependabot metadata
        id: metadata
        # v2.5.0
        uses: dependabot/fetch-metadata@fa6d7aee4f734d7f1a20fb075d01c7db6731009d
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Detect GPU-only manifests
        id: manifest
        if: ${{ steps.metadata.outputs['package-ecosystem'] == 'pip' }}
        env:
          MANIFEST_NAME: ${{ steps.metadata.outputs['manifest-name'] }}
        run: |
          set -euo pipefail

          write_summary() {
            if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
              mkdir -p "$(dirname "$GITHUB_STEP_SUMMARY")"
              printf '%s\n' "$1" >>"$GITHUB_STEP_SUMMARY"
            else
              printf '%s\n' "$1"
            fi
          }

          if [[ -z "${MANIFEST_NAME}" ]]; then
            echo "requires_gpu=false" >>"$GITHUB_OUTPUT"
            exit 0
          fi

          shopt -s nocasematch
          if [[ "${MANIFEST_NAME}" == requirements-gpu.* ]]; then
            echo "requires_gpu=true" >>"$GITHUB_OUTPUT"
            write_summary "Skipping GPU-specific manifest '${MANIFEST_NAME}' to avoid installing unavailable CUDA dependencies."
          else
            echo "requires_gpu=false" >>"$GITHUB_OUTPUT"
          fi
          shopt -u nocasematch

      - name: Auto approve
        if: >-
          steps.metadata.outputs['update-type'] != 'version-update:semver-major' &&
          steps.manifest.outputs.requires_gpu != 'true'
        # v4.0.0
        uses: hmarr/auto-approve-action@8f929096a962e83ccdfa8afcf855f39f12d4dac7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          pull-request-number: ${{ (github.event.pull_request && github.event.pull_request.number) || '' }}
      - name: Checkout code
        if: ${{ steps.metadata.outputs['package-ecosystem'] == 'pip' && steps.manifest.outputs.requires_gpu != 'true' }}
        # v5.0.0
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3
        with:
          # Do not expose a writable token to the checked-out repository when
          # running in the pull_request_target context.  Dependabot updates are
          # trusted, but GitHub still reports an injection risk unless the
          # credentials are explicitly dropped.
          persist-credentials: false
          fetch-depth: 0
          repository: ${{ github.repository }}
          ref: ${{ (github.event.pull_request && github.event.pull_request.head.sha) || github.sha }}

      # Set up a lightweight Python environment and install only the
      # dependencies required to run the unit tests.  This avoids the
      # heavier setup used in the main CI workflow which was causing
      # Dependabot update checks to fail.
      - name: Setup Python
        if: ${{ steps.metadata.outputs['package-ecosystem'] == 'pip' && steps.manifest.outputs.requires_gpu != 'true' }}
        # v6.0.0
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c
        with:
          python-version: '3.11'
          cache: 'pip'
      - name: Install dependencies
        if: >-
          steps.metadata.outputs['package-ecosystem'] == 'pip' &&
          github.event.pull_request.head.repo.full_name == github.repository &&
          steps.manifest.outputs.requires_gpu != 'true'
        run: |
          python -m pip install --upgrade pip
          python -m pip install -e .
          python -m pip install -r requirements-ci.txt

      - name: Install manifest requirements
        if: >-
          steps.metadata.outputs['package-ecosystem'] == 'pip' &&
          github.event.pull_request.head.repo.full_name == github.repository &&
          steps.metadata.outputs['manifest-path'] != '' &&
          steps.manifest.outputs.requires_gpu != 'true'
        env:
          MANIFEST_PATH: ${{ steps.metadata.outputs['manifest-path'] }}
          MANIFEST_NAME: ${{ steps.metadata.outputs['manifest-name'] }}
        run: |
          set -euo pipefail

          manifest_path="${MANIFEST_PATH}"
          if [[ ! -f "${manifest_path}" ]]; then
            echo "Manifest ${manifest_path} not found; skipping install."
            exit 0
          fi

          case "${MANIFEST_NAME}" in
            requirements*.txt|requirements*.in|*.txt|*.in)
              python -m pip install --upgrade -r "${manifest_path}"
              ;;
            *)
              echo "Manifest ${manifest_path} is not a requirements file; skipping install."
              ;;
          esac

      # Ensure the tests exercise the exact versions proposed by Dependabot
      # even when the manifest being updated is not part of the lean
      # requirements set we install above (for example, updates targeting
      # requirements.txt or pyproject.toml).  The metadata action provides the
      # dependency names and versions so we can install them explicitly without
      # resolving the entire environment from scratch, keeping the job fast
      # while still validating the new packages.
      - name: Install Dependabot updates
        if: >-
          steps.metadata.outputs['package-ecosystem'] == 'pip' &&
          github.event.pull_request.head.repo.full_name == github.repository &&
          steps.manifest.outputs.requires_gpu != 'true'
        env:
          DEPENDENCIES_JSON: ${{ steps.metadata.outputs['updated-dependencies-json'] }}
        run: |
          python <<'PY'
          import json
          import os
          import subprocess
          import sys

          raw = os.environ.get("DEPENDENCIES_JSON", "").strip()
          if not raw:
              print("No dependency metadata provided; skipping targeted installs.")
              raise SystemExit(0)

          try:
              dependencies = json.loads(raw)
          except json.JSONDecodeError as exc:  # pragma: no cover - workflow safety
              print(f"Failed to parse Dependabot metadata: {exc}")
              raise SystemExit(1)

          if not dependencies:
              print("Dependabot metadata did not list dependencies; skipping.")
              raise SystemExit(0)

          for dependency in dependencies:
              name = dependency.get("dependency-name")
              # Dependabot uses "new-version" for regular updates and
              # "dependency-version" for security advisories.  Support both so
              # the workflow always installs the proposed version before
              # running the tests.
              version = dependency.get("new-version") or dependency.get("dependency-version")
              if not name or not version:
                  print(f"Skipping entry without name/version: {dependency}")
                  continue

              spec = f"{name}=={version}"
              print(
                  "Installing updated dependency "
                  f"{spec} with eager dependency upgrades"
              )
              subprocess.run(
                  [
                      sys.executable,
                      "-m",
                      "pip",
                      "install",
                      "--upgrade",
                      "--upgrade-strategy",
                      "eager",
                      spec,
                  ],
                  check=True,
              )

          check_proc = subprocess.run(
              [sys.executable, "-m", "pip", "check"],
              capture_output=True,
              text=True,
          )
          if check_proc.returncode != 0:
              print("pip check detected dependency conflicts after installing updates.")
              if check_proc.stdout:
                  print(check_proc.stdout)
              if check_proc.stderr:
                  print(check_proc.stderr, file=sys.stderr)
              raise SystemExit(check_proc.returncode)
          else:
              if check_proc.stdout:
                  print(check_proc.stdout)
              if check_proc.stderr:
                  print(check_proc.stderr, file=sys.stderr)
          PY

      # Run the unit tests against the Dependabot update.  Integration
      # tests are excluded here to keep the workflow fast; they run in
      # the main CI.  If any test fails this step will surface the
      # error and prevent automatic merging of the pull request.
      - name: Run unit tests
        if: >-
          steps.metadata.outputs['package-ecosystem'] == 'pip' &&
          github.event.pull_request.head.repo.full_name == github.repository &&
          steps.manifest.outputs.requires_gpu != 'true'
        run: pytest -m "not integration" -q

      - name: Report skipped GPU validation
        if: >-
          steps.metadata.outputs['package-ecosystem'] == 'pip' &&
          steps.manifest.outputs.requires_gpu == 'true'
        run: |
          write_summary() {
            if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
              mkdir -p "$(dirname "$GITHUB_STEP_SUMMARY")"
              printf '%s\n' "$1" >>"$GITHUB_STEP_SUMMARY"
            else
              printf '%s\n' "$1"
            fi
          }

          write_summary "GPU-specific dependency updates require manual verification. Tests were skipped to avoid missing CUDA runtimes."
          write_summary "Auto-approve and auto-merge were disabled automatically for this update."

      - name: Check auto-merge availability
        id: auto_merge
        env:
          ALLOW_AUTO_MERGE: ${{ github.event.repository.allow_auto_merge == true }}
        run: |
          write_summary() {
            if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
              mkdir -p "$(dirname "$GITHUB_STEP_SUMMARY")"
              printf '%s\n' "$1" >>"$GITHUB_STEP_SUMMARY"
            else
              printf '%s\n' "$1"
            fi
          }

          if [[ "${ALLOW_AUTO_MERGE}" == 'true' ]]; then
            echo "allowed=true" >> "$GITHUB_OUTPUT"
          else
            echo "allowed=false" >> "$GITHUB_OUTPUT"
            write_summary "Auto-merge is disabled for this repository; skipping enablement."
          fi

      - name: Enable auto-merge for Dependabot PRs
        id: enable_automerge
        if: >-
          steps.auto_merge.outputs.allowed == 'true' &&
          steps.metadata.outputs['update-type'] != 'version-update:semver-major' &&
          steps.manifest.outputs.requires_gpu != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          PR_NUMBER: ${{ (github.event.pull_request && github.event.pull_request.number) || '' }}
        shell: bash
        run: |
          set -uo pipefail

          write_summary() {
            if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
              mkdir -p "$(dirname "$GITHUB_STEP_SUMMARY")"
              printf '%s\n' "$1" >>"$GITHUB_STEP_SUMMARY"
            else
              printf '%s\n' "$1"
            fi
          }

          api_url="https://api.github.com/repos/${OWNER}/${REPO}/pulls/${PR_NUMBER}/auto-merge"
          payload='{"merge_method":"squash"}'

          if ! status=$(curl \
            --silent \
            --show-error \
            --location \
            --output response.json \
            --write-out '%{http_code}' \
            --request PUT "${api_url}" \
            --header 'Accept: application/vnd.github+json' \
            --header "Authorization: Bearer ${GH_TOKEN}" \
            --data "${payload}"); then
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "status=transport-error" >> "$GITHUB_OUTPUT"
            write_summary "Unable to contact the GitHub API to enable auto-merge."
            exit 0
          fi

          if [[ "${status}" =~ ^2 ]]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
            write_summary "Auto-merge enabled successfully (HTTP ${status})."
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "status=${status}" >> "$GITHUB_OUTPUT"
            write_summary "Unable to enable auto-merge automatically (HTTP ${status})."
            if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
              cat response.json >>"$GITHUB_STEP_SUMMARY"
            else
              cat response.json
            fi
          fi

          rm -f response.json

      - name: Report auto-merge failure
        if: ${{ steps.enable_automerge.outputs.enabled == 'false' }}
        run: |
          write_summary() {
            if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
              mkdir -p "$(dirname "$GITHUB_STEP_SUMMARY")"
              printf '%s\n' "$1" >>"$GITHUB_STEP_SUMMARY"
            else
              printf '%s\n' "$1"
            fi
          }

          write_summary "Auto-merge could not be enabled automatically. Check repository settings or branch protection rules."
