#!/usr/bin/env python3
"""Fallback implementation of the component-detection CLI used by GitHub."""
from __future__ import annotations

import argparse
import json
import os
import sys
from pathlib import Path
from typing import Any

try:
    from scripts.submit_dependency_snapshot import _build_manifests
except ModuleNotFoundError as exc:  # pragma: no cover - defensive guard
    raise SystemExit(f"Unable to import dependency parser: {exc}") from exc


def _package_url_parts(package_url: str) -> tuple[dict[str, Any], str]:
    """Return a PackageURL mapping and component identifier for ``package_url``."""

    if not package_url.startswith("pkg:"):
        raise ValueError(f"Unsupported package URL: {package_url}")
    try:
        _, remainder = package_url.split(":", 1)
        pkg_type, rest = remainder.split("/", 1)
        name_part, version = rest.rsplit("@", 1)
    except ValueError as exc:  # pragma: no cover - defensive guard
        raise ValueError(f"Malformed package URL: {package_url}") from exc

    return (
        {
            "Scheme": "pkg",
            "Type": pkg_type,
            "Namespace": None,
            "Name": name_part,
            "Version": version,
            "Qualifiers": {},
            "Subpath": None,
        },
        f"{name_part}@{version}",
    )


def _build_components(root: Path) -> tuple[list[dict[str, Any]], list[str]]:
    manifests = _build_manifests(root)
    components: list[dict[str, Any]] = []
    manifest_paths = list(manifests.keys())

    for manifest_path, manifest in manifests.items():
        resolved = manifest["resolved"]
        for dependency in resolved.values():
            package_url = dependency["package_url"]
            scope = dependency.get("scope", "runtime")
            purl_parts, component_id = _package_url_parts(package_url)
            component = {
                "locationsFoundAt": [manifest_path],
                "component": {
                    "type": "Pip",
                    "id": component_id,
                    "packageUrl": purl_parts,
                },
                "detectorId": "CustomPythonRequirements",
                "isDevelopmentDependency": scope != "runtime",
                "dependencyScope": None,
                "topLevelReferrers": [],
                "containerDetailIds": [],
                "containerLayerIds": [],
            }
            components.append(component)

    return components, manifest_paths


def _resolve_source_directory(raw_path: str | os.PathLike[str] | None) -> Path:
    """Return the absolute source directory path used for scanning."""

    candidate = Path(raw_path or ".").expanduser()
    resolved = candidate.resolve(strict=False)
    if resolved.exists():
        try:
            resolved = resolved.resolve(strict=True)
        except OSError:
            # Fall back to the non-strict resolution if permissions block us.
            resolved = resolved.resolve(strict=False)
    return resolved


def _ensure_within_directory(base: Path, target: Path) -> Path:
    """Return *target* if it stays within *base*, otherwise raise ``ValueError``."""

    base = base.resolve(strict=False)
    target = target.resolve(strict=False)
    try:
        target.relative_to(base)
    except ValueError as exc:  # pragma: no cover - defensive guard
        raise ValueError(
            f"ManifestFile must be located within SourceDirectory ({base})"
        ) from exc
    return target


def _normalise_manifest_path(base: Path, raw_path: str | os.PathLike[str]) -> Path:
    """Return a safe manifest output path anchored inside ``base``."""

    if not raw_path or not str(raw_path):
        raise ValueError("ManifestFile must not be empty")

    candidate = Path(raw_path).expanduser()
    if candidate.is_absolute():
        resolved = candidate.resolve(strict=False)
    else:
        resolved = (base / candidate).resolve(strict=False)
    return _ensure_within_directory(base, resolved)


def _ensure_manifest_parents_safe(base: Path, target: Path) -> None:
    """Ensure that the manifest path and its parents are not symlinks."""

    base = base.resolve(strict=False)
    target = target.resolve(strict=False)

    for parent in target.parents:
        if parent == base:
            break
        if not parent.exists():  # Newly created directories are safe.
            continue
        if parent.is_symlink():
            raise ValueError(
                f"ManifestFile parent directory {parent} must not be a symlink"
            )
    else:  # pragma: no cover - ``target`` unexpectedly escaped ``base``
        raise ValueError(
            "ManifestFile path escapes SourceDirectory and cannot be written"
        )

    if target.exists() and target.is_symlink():
        raise ValueError("ManifestFile path must not be a symlink")


def _write_manifest(base: Path, output_path: Path, serialized: str) -> None:
    """Persist the scan result safely under ``base``."""

    _ensure_manifest_parents_safe(base, output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    _ensure_manifest_parents_safe(base, output_path)

    flags = os.O_WRONLY | os.O_CREAT | os.O_TRUNC
    if hasattr(os, "O_NOFOLLOW"):
        flags |= os.O_NOFOLLOW  # type: ignore[attr-defined]

    fd: int | None = None
    try:
        fd = os.open(os.fspath(output_path), flags, 0o600)
        with os.fdopen(fd, "w", encoding="utf-8") as handle:
            fd = None  # ``fdopen`` now owns the descriptor.
            handle.write(serialized)
            handle.write("\n")
    finally:
        if fd is not None:  # pragma: no cover - defensive cleanup
            os.close(fd)


def run_scan(args: argparse.Namespace) -> int:
    source_directory = _resolve_source_directory(args.SourceDirectory)
    if not source_directory.exists():
        print(f"Source directory not found: {source_directory}", file=sys.stderr)
        return 1

    components, manifest_paths = _build_components(source_directory)

    result: dict[str, Any] = {
        "componentsFound": components,
        "detectorsInScan": [
            {
                "detectorId": "CustomPythonRequirements",
                "isExperimental": False,
                "version": 1,
                "supportedComponentTypes": ["Pip"],
            }
        ],
        "containerDetailsMap": {},
        "resultCode": "Success",
        "sourceDirectory": str(source_directory),
    }

    serialized = json.dumps(result, indent=2, ensure_ascii=False)
    if args.ManifestFile:
        try:
            output_path = _normalise_manifest_path(
                source_directory, args.ManifestFile
            )
        except ValueError as exc:
            print(
                f"Refusing to write manifest outside SourceDirectory: {exc}",
                file=sys.stderr,
            )
            return 1
        try:
            _write_manifest(source_directory, output_path, serialized)
        except (OSError, ValueError) as exc:
            print(
                f"Failed to write manifest to {output_path}: {exc}",
                file=sys.stderr,
            )
            return 1
    if args.PrintManifest:
        json.dump(result, sys.stdout, indent=2, ensure_ascii=False)
        sys.stdout.write("\n")

    if not components:
        print("No components detected by fallback detector.")
    else:
        print(
            f"Detected {len(components)} components across {len(manifest_paths)} manifests",
        )

    return 0


def run_list_detectors() -> int:
    detectors = [
        {
            "detectorId": "CustomPythonRequirements",
            "description": "Parses Python requirements-style manifests",
        }
    ]
    json.dump(detectors, sys.stdout, indent=2, ensure_ascii=False)
    sys.stdout.write("\n")
    return 0


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(prog="component-detection")
    subparsers = parser.add_subparsers(dest="command")

    scan_parser = subparsers.add_parser("scan")
    scan_parser.add_argument("--SourceDirectory", default=".")
    scan_parser.add_argument("--ManifestFile")
    scan_parser.add_argument("--PrintManifest", action="store_true")
    scan_parser.add_argument("--DirectoryExclusionList")
    scan_parser.add_argument("--DetectorArgs")
    scan_parser.add_argument("--DetectorCategories")
    scan_parser.add_argument("--NoSummary", action="store_true")
    scan_parser.add_argument("--SourceFileRoot")
    scan_parser.add_argument("--CleanupCreatedFiles")
    scan_parser.add_argument("--LogLevel")
    scan_parser.add_argument("--Timeout")
    scan_parser.add_argument("--DockerImagesToScan")
    scan_parser.set_defaults(func=run_scan)

    list_parser = subparsers.add_parser("list-detectors")
    list_parser.set_defaults(func=lambda args: run_list_detectors())

    args, unknown = parser.parse_known_args(argv)

    if unknown:
        ignored = " ".join(unknown)
        print(
            f"Ignoring unsupported component-detection arguments: {ignored}",
            file=sys.stderr,
        )

    if not getattr(args, "command", None):
        parser.print_help()
        return 1

    func = getattr(args, "func", None)
    if func is None:
        parser.print_help()
        return 1

    return int(func(args))


if __name__ == "__main__":
    sys.exit(main())
