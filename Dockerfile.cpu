# syntax=docker/dockerfile:1.6

FROM python:3.11-slim AS builder
ARG DEBIAN_FRONTEND=noninteractive

# Поведение Python по умолчанию с буферизацией stdout усложняет отладку
# журналов в GitHub Actions. Выключаем буферизацию сразу в базовом образе,
# чтобы любые ``print``-сообщения появлялись мгновенно.
ENV PYTHONUNBUFFERED=1

# Обновляем базовый образ до актуальных патчей безопасности и устанавливаем
# минимальный набор инструментов, необходимый для сборки виртуального
# окружения. Использование официального python:3.11-slim позволяет избежать
# ненадёжного ручного управления PPA и делает сборку устойчивой к ошибкам
# "Release file not found" в GitHub Actions.
RUN <<'EOSHELL'
set -eux
apt-get update
apt-get upgrade -y
apt-get install -y --no-install-recommends \
    build-essential \
    ca-certificates \
    curl
rm -rf /var/lib/apt/lists/*
EOSHELL

WORKDIR /app

COPY requirements-core.txt .

ENV VIRTUAL_ENV=/opt/venv

# Строго убеждаемся, что в сборочном образе доступен Python 3.11. Именно
# отсутствие бинарника python3.11 в прошлых сборках вызывало падения "exit
# code 127" на шаге docker-publish. Такой ранний контроль делает причину
# проблемы очевидной и предотвращает регресс при смене базового образа.
RUN python - <<'PY'
import sys
major, minor = sys.version_info[:2]
if (major, minor) != (3, 11):
    raise SystemExit(
        f"Builder Python version mismatch: expected 3.11, got {major}.{minor}"
    )
PY

# pip>=24.0 устраняет CVE-2023-32681, setuptools>=78.1.1 закрывает известные
# уязвимости и совместимы с зависимостями проекта.
RUN python -m venv "$VIRTUAL_ENV"

RUN "$VIRTUAL_ENV"/bin/python -m ensurepip --upgrade

RUN "$VIRTUAL_ENV"/bin/pip install --no-cache-dir \
        'pip>=24.0' \
        'setuptools>=78.1.1,<81' \
        wheel

RUN "$VIRTUAL_ENV"/bin/pip install --no-cache-dir \
        --extra-index-url https://download.pytorch.org/whl/cpu \
        -r requirements-core.txt

RUN "$VIRTUAL_ENV"/bin/python - <<'PY'
import textwrap

exec(textwrap.dedent("""
    import hashlib
    import pathlib
    from tempfile import NamedTemporaryFile
    from urllib.parse import urlsplit

    import requests

    COMMONS_LANG3_URL = (
        "https://repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.18.0/"
        "commons-lang3-3.18.0.jar"
    )
    COMMONS_LANG3_SHA256 = (
        "4eeeae8d20c078abb64b015ec158add383ac581571cddc45c68f0c9ae0230720"
    )
    COMMONS_LANG3_ALLOWED_HOST = "repo1.maven.org"

    try:
        import ray  # type: ignore
    except Exception:
        print("Ray отсутствует, пропускаем обновление commons-lang3")
    else:
        jars_dir = pathlib.Path(ray.__file__).resolve().parent / "jars"
        jars_dir.mkdir(parents=True, exist_ok=True)
        for jar in jars_dir.glob("commons-lang3-*.jar"):
            jar.unlink()
        destination = jars_dir / "commons-lang3-3.18.0.jar"
        hasher = hashlib.sha256()

        parsed_url = urlsplit(COMMONS_LANG3_URL)
        if parsed_url.scheme != "https":
            raise RuntimeError(
                "Ожидалась схема https при скачивании commons-lang3, "
                f"получено: {parsed_url.scheme}"
            )
        if parsed_url.netloc != COMMONS_LANG3_ALLOWED_HOST:
            raise RuntimeError(
                "Получен неожиданный хост при скачивании commons-lang3: "
                f"{parsed_url.netloc}"
            )

        temp_path = None
        try:
            with requests.Session() as session:
                adapter = requests.adapters.HTTPAdapter()
                session.mount("https://", adapter)
                session.trust_env = False
                with session.get(
                    COMMONS_LANG3_URL,
                    stream=True,
                    timeout=30,
                    allow_redirects=False,
                ) as response:
                    if 300 <= response.status_code < 400:
                        location = response.headers.get("Location", "")
                        raise RuntimeError(
                            "commons-lang3 download unexpectedly redirected"
                            + (f" to {location}" if location else "")
                        )
                    response.raise_for_status()
                    with NamedTemporaryFile(
                        "wb", delete=False, dir=jars_dir
                    ) as temp_file:
                        temp_path = pathlib.Path(temp_file.name)
                        for chunk in response.iter_content(chunk_size=8192):
                            if not chunk:
                                continue
                            temp_file.write(chunk)
                            hasher.update(chunk)
        except Exception:
            if temp_path is not None:
                temp_path.unlink(missing_ok=True)
            raise

        if temp_path is None:
            raise RuntimeError("Failed to create temporary commons-lang3 download")

        digest = hasher.hexdigest()
        if digest != COMMONS_LANG3_SHA256:
            destination.unlink(missing_ok=True)
            temp_path.unlink(missing_ok=True)
            raise RuntimeError(
                "SHA256 mismatch while downloading commons-lang3: expected "
                f"{COMMONS_LANG3_SHA256}, got {digest}"
            )

        try:
            temp_path.replace(destination)
        except Exception:
            temp_path.unlink(missing_ok=True)
            raise
"""))
PY

# NOTE: keep the cleanup below in a dedicated RUN step. Using an explicit Bash
# invocation with ``set -euo pipefail`` prevents the Docker parser from
# splitting the first command token (``nvidia_packages=...``) into a separate
# instruction, a behaviour that historically produced "dockerfile parse error"
# failures in the docker-publish workflow. Historical context:
# https://github.com/averinaleks/bot/actions/workflows/docker-publish.yml

RUN /bin/bash -euo pipefail -c "\
  nvidia_packages=\"\$($VIRTUAL_ENV/bin/pip freeze | grep -i '^nvidia-' || true)\"; \
  if [ -n \"\$nvidia_packages\" ]; then \
    printf '%s\\n' \"\$nvidia_packages\" | cut -d= -f1 | xargs -r $VIRTUAL_ENV/bin/pip uninstall -y; \
  else \
    echo 'No NVIDIA packages detected in the virtual environment'; \
  fi; \
  find \"$VIRTUAL_ENV\" -type d -name '__pycache__' -exec rm -rf {} +; \
  find \"$VIRTUAL_ENV\" -type f -name '*.pyc' -delete\
"

FROM python:3.11-slim
ARG DEBIAN_FRONTEND=noninteractive

ENV PYTHONUNBUFFERED=1

# Обновляем систему и добавляем только необходимые зависимости выполнения.
# libgomp1 требуется бинарям NumPy/Scikit-learn, а libssl3 необходим для
# криптографических библиотек.
RUN <<'EOSHELL'
set -eux
apt-get update
apt-get upgrade -y
apt-get install -y --no-install-recommends \
    libgomp1 \
    libssl3
rm -rf /var/lib/apt/lists/*
EOSHELL

# Проверяем, что рантайм тоже использует Python 3.11. Это гарантирует,
# что окружение исполнения совпадает со сборочным и мы не столкнёмся с
# несовместимостью зависимостей.
RUN python - <<'PY'
import sys
major, minor = sys.version_info[:2]
if (major, minor) != (3, 11):
    raise SystemExit(
        f"Runtime Python version mismatch: expected 3.11, got {major}.{minor}"
    )
PY

WORKDIR /app

COPY --from=builder /opt/venv /app/venv
COPY . .

ENV VIRTUAL_ENV=/app/venv
ENV PATH="$VIRTUAL_ENV/bin:$PATH"

# Verify that all heavy packages were installed and no GPU libraries remain.
# ``mlflow`` is an optional dependency and may be absent in the base image, so
# we report its status without failing the build when it's not installed.
RUN $VIRTUAL_ENV/bin/python - <<'PY'
import importlib

print("Checking package versions...")

required_modules = (
    ("torch", "Torch"),
    ("stable_baselines3", "SB3"),
    ("pytorch_lightning", "Lightning"),
)

for module_name, label in required_modules:
    module = importlib.import_module(module_name)
    version = getattr(module, "__version__", "<unknown>")
    print(f"{label}: {version}")

try:
    mlflow = importlib.import_module("mlflow")
except ModuleNotFoundError:
    print("MLflow: not installed (optional)")
else:
    print(f"MLflow: {getattr(mlflow, '__version__', '<unknown>')}")
PY

RUN if /app/venv/bin/pip freeze | grep -qi nvidia; then \
        echo 'Unexpected NVIDIA packages found' >&2; \
        exit 1; \
    else \
        echo 'No NVIDIA packages installed'; \
    fi

# Use a dedicated non-root user for runtime
RUN groupadd --system bot && useradd --system --gid bot --home-dir /home/bot --shell /bin/bash bot && \
    mkdir -p /home/bot && \
    chown -R bot:bot /app /home/bot

USER bot

CMD ["/app/venv/bin/python", "-m", "bot.trading_bot"]
