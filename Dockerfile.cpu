# syntax=docker/dockerfile:1.6

FROM python:3.11-slim AS builder
# PyTorch 2.9.0, зафиксированный в requirements-core.txt, пока не выпускает
# колёса для Python 3.12 (см. pip download --python-version 3.12). Поэтому
# используем Python 3.11, где колёса доступны и сборка Docker-образа не
# прерывается на установке torch.
ARG DEBIAN_FRONTEND=noninteractive

# Поведение Python по умолчанию с буферизацией stdout усложняет отладку
# журналов в GitHub Actions. Выключаем буферизацию сразу в базовом образе,
# чтобы любые ``print``-сообщения появлялись мгновенно.
ENV PYTHONUNBUFFERED=1

# Обновляем индекс пакетов и устанавливаем минимальный набор инструментов,
# необходимый для сборки виртуального окружения. Semgrep (правило
# ``dockerfile.security.apt-get-upgrade``) запрещает использование
# ``apt-get upgrade``, поэтому поддержка безопасности возлагается на
# своевременное обновление базового образа. Использование официального
# python:3.11-slim по-прежнему избавляет от ручных PPA и «Release file not
# found» в GitHub Actions.
RUN <<'EOSHELL'
set -eux
apt-get update \
    && apt-get install -y --no-install-recommends \
        build-essential \
        ca-certificates \
        curl \
    && rm -rf /var/lib/apt/lists/*
EOSHELL

WORKDIR /app

COPY requirements-core.txt .

ENV VIRTUAL_ENV=/opt/venv

# Строго убеждаемся, что в сборочном образе доступен Python 3.11. Именно
# отсутствие бинарника python3.11 в прошлых сборках вызывало падения "exit
# code 127" на шаге docker-publish. Такой ранний контроль делает причину
# проблемы очевидной и предотвращает регресс при смене базового образа.
RUN python - <<'PY'
from __future__ import annotations

import os
import tarfile
from pathlib import Path

import pip

unpacking = Path(pip.__file__).resolve().parent / "_internal" / "utils" / "unpacking.py"
source = unpacking.read_text()

if "def is_symlink_target_in_tar(" in source:
    print("pip tar symlink guard already present; skipping patch")
else:
    helper = "\n".join([
        "",
        "def is_symlink_target_in_tar(tar: tarfile.TarFile, tarinfo: tarfile.TarInfo) -> bool:",
        '    """Check if the file pointed to by the symbolic link is in the tar archive."""',
        "    linkname = os.path.join(os.path.dirname(tarinfo.name), tarinfo.linkname)",
        "    linkname = os.path.normpath(linkname)",
        '    linkname = linkname.replace("\\", "/")',
        "    try:",
        "        tar.getmember(linkname)",
        "        return True",
        "    except KeyError:",
        "        return False",
        "",
    ])
    comment = "\n".join([
        "    # NOTE: This function can be removed once pip requires CPython ≥ 3.12.",
        "    # PEP 706 added tarfile.data_filter, made tarfile extraction operations more secure.",
        "    # This feature is fully supported from CPython 3.12 onward.",
    ])
    sentinel_options = [
        '    """Fallback for Python without tarfile.data_filter"""',
        '    """Fallback for Python without tarfile.data_filter."""',
    ]
    sentinel = next((option for option in sentinel_options if option in source), None)

    if sentinel is None:
        print("::warning::pip layout changed; fallback docstring not found; skipping symlink guard patch")
    else:
        target_header = f"{sentinel}\n    for member"
        if target_header not in source:
            print("::warning::pip layout changed; fallback loop header not found; skipping symlink guard patch")
        else:
            old_variants = [
                "        elif member.issym():\n            try:\n                tar._extract_member(member, path)\n",
            ]
            for old in old_variants:
                if old in source:
                    new_block = "\n".join([
                        "        elif member.issym():",
                        "            if not is_symlink_target_in_tar(tar, member):",
                        "                message = (",
                        '                    "The tar file ({}) has a file ({}) trying to install "',
                        '                    "outside target directory ({})"',
                        "                )",
                        "                raise InstallationError(",
                        "                    message.format(filename, member.name, member.linkname)",
                        "                )",
                        "            try:",
                        "                tar._extract_member(member, path)",
                    ])
                    updated = source.replace("def _untar_without_filter(", helper + "def _untar_without_filter(", 1)
                    updated = updated.replace(
                        target_header,
                        f"{sentinel}\n{comment}\n    for member",
                        1,
                    )
                    updated = updated.replace(old, new_block, 1)
                    unpacking.write_text(updated)
                    print("Patched pip tar symlink extraction guard")
                    break
            else:
                print("::warning::pip layout changed; symlink branch not found; skipping symlink guard patch")

PY
    && python -m pip cache purge

# pip>=25.2 доступен на момент написания. Ниже мы патчим установленный pip, добавляя
# проверку символических ссылок из релиза 25.3 (исправление CVE-2025-8869). setuptools>=80.9.0
# закрывает известные уязвимости и совместим с зависимостями проекта.
RUN python -m venv "$VIRTUAL_ENV"

RUN "$VIRTUAL_ENV"/bin/python -m ensurepip --upgrade

RUN "$VIRTUAL_ENV"/bin/pip install --no-cache-dir \
        'pip>=25.2' \
        'setuptools>=80.9.0,<81' \
        wheel \
    && "$VIRTUAL_ENV"/bin/python - <<'PY'
from __future__ import annotations

import os
import tarfile
from pathlib import Path

import pip

unpacking = Path(pip.__file__).resolve().parent / "_internal" / "utils" / "unpacking.py"
source = unpacking.read_text()

if "def is_symlink_target_in_tar(" in source:
    print("pip tar symlink guard already present; skipping patch")
else:
    helper = "\n".join([
        "",
        "def is_symlink_target_in_tar(tar: tarfile.TarFile, tarinfo: tarfile.TarInfo) -> bool:",
        '    """Check if the file pointed to by the symbolic link is in the tar archive."""',
        "    linkname = os.path.join(os.path.dirname(tarinfo.name), tarinfo.linkname)",
        "    linkname = os.path.normpath(linkname)",
        '    linkname = linkname.replace("\\", "/")',
        "    try:",
        "        tar.getmember(linkname)",
        "        return True",
        "    except KeyError:",
        "        return False",
        "",
    ])
    comment = "\n".join([
        "    # NOTE: This function can be removed once pip requires CPython ≥ 3.12.",
        "    # PEP 706 added tarfile.data_filter, made tarfile extraction operations more secure.",
        "    # This feature is fully supported from CPython 3.12 onward.",
    ])
    sentinel_options = [
        '    """Fallback for Python without tarfile.data_filter"""',
        '    """Fallback for Python without tarfile.data_filter."""',
    ]
    sentinel = next((option for option in sentinel_options if option in source), None)

    if sentinel is None:
        print("::warning::pip layout changed; fallback docstring not found; skipping symlink guard patch")
    else:
        target_header = f"{sentinel}\n    for member"
        if target_header not in source:
            print("::warning::pip layout changed; fallback loop header not found; skipping symlink guard patch")
        else:
            old_variants = [
                "        elif member.issym():\n            try:\n                tar._extract_member(member, path)\n",
            ]
            for old in old_variants:
                if old in source:
                    new_block = "\n".join([
                        "        elif member.issym():",
                        "            if not is_symlink_target_in_tar(tar, member):",
                        "                message = (",
                        '                    "The tar file ({}) has a file ({}) trying to install "',
                        '                    "outside target directory ({})"',
                        "                )",
                        "                raise InstallationError(",
                        "                    message.format(filename, member.name, member.linkname)",
                        "                )",
                        "            try:",
                        "                tar._extract_member(member, path)",
                    ])
                    updated = source.replace("def _untar_without_filter(", helper + "def _untar_without_filter(", 1)
                    updated = updated.replace(
                        target_header,
                        f"{sentinel}\n{comment}\n    for member",
                        1,
                    )
                    updated = updated.replace(old, new_block, 1)
                    unpacking.write_text(updated)
                    print("Patched pip tar symlink extraction guard")
                    break
            else:
                print("::warning::pip layout changed; symlink branch not found; skipping symlink guard patch")

PY

RUN "$VIRTUAL_ENV"/bin/pip install --no-cache-dir \
        --extra-index-url https://download.pytorch.org/whl/cpu \
        -r requirements-core.txt

RUN "$VIRTUAL_ENV"/bin/python - <<'PY'
from __future__ import annotations

import os
import tarfile
from pathlib import Path

import pip

unpacking = Path(pip.__file__).resolve().parent / "_internal" / "utils" / "unpacking.py"
source = unpacking.read_text()

if "def is_symlink_target_in_tar(" in source:
    print("pip tar symlink guard already present; skipping patch")
else:
    helper = "\n".join([
        "",
        "def is_symlink_target_in_tar(tar: tarfile.TarFile, tarinfo: tarfile.TarInfo) -> bool:",
        '    """Check if the file pointed to by the symbolic link is in the tar archive."""',
        "    linkname = os.path.join(os.path.dirname(tarinfo.name), tarinfo.linkname)",
        "    linkname = os.path.normpath(linkname)",
        '    linkname = linkname.replace("\\", "/")',
        "    try:",
        "        tar.getmember(linkname)",
        "        return True",
        "    except KeyError:",
        "        return False",
        "",
    ])
    comment = "\n".join([
        "    # NOTE: This function can be removed once pip requires CPython ≥ 3.12.",
        "    # PEP 706 added tarfile.data_filter, made tarfile extraction operations more secure.",
        "    # This feature is fully supported from CPython 3.12 onward.",
    ])
    sentinel_options = [
        '    """Fallback for Python without tarfile.data_filter"""',
        '    """Fallback for Python without tarfile.data_filter."""',
    ]
    sentinel = next((option for option in sentinel_options if option in source), None)

    if sentinel is None:
        print("::warning::pip layout changed; fallback docstring not found; skipping symlink guard patch")
    else:
        target_header = f"{sentinel}\n    for member"
        if target_header not in source:
            print("::warning::pip layout changed; fallback loop header not found; skipping symlink guard patch")
        else:
            old_variants = [
                "        elif member.issym():\n            try:\n                tar._extract_member(member, path)\n",
            ]
            for old in old_variants:
                if old in source:
                    new_block = "\n".join([
                        "        elif member.issym():",
                        "            if not is_symlink_target_in_tar(tar, member):",
                        "                message = (",
                        '                    "The tar file ({}) has a file ({}) trying to install "',
                        '                    "outside target directory ({})"',
                        "                )",
                        "                raise InstallationError(",
                        "                    message.format(filename, member.name, member.linkname)",
                        "                )",
                        "            try:",
                        "                tar._extract_member(member, path)",
                    ])
                    updated = source.replace("def _untar_without_filter(", helper + "def _untar_without_filter(", 1)
                    updated = updated.replace(
                        target_header,
                        f"{sentinel}\n{comment}\n    for member",
                        1,
                    )
                    updated = updated.replace(old, new_block, 1)
                    unpacking.write_text(updated)
                    print("Patched pip tar symlink extraction guard")
                    break
            else:
                print("::warning::pip layout changed; symlink branch not found; skipping symlink guard patch")

PY
    && python -m pip cache purge

WORKDIR /app

COPY --from=builder /opt/venv /app/venv
COPY . .

ENV VIRTUAL_ENV=/app/venv
ENV PATH="$VIRTUAL_ENV/bin:$PATH"

# Verify that all heavy packages were installed and no GPU libraries remain.
# ``mlflow`` is an optional dependency and may be absent in the base image, so
# we report its status without failing the build when it's not installed.
RUN $VIRTUAL_ENV/bin/python - <<'PY'
import importlib

print("Checking package versions...")

required_modules = (
    ("torch", "Torch"),
    ("stable_baselines3", "SB3"),
    ("pytorch_lightning", "Lightning"),
)

for module_name, label in required_modules:
    module = importlib.import_module(module_name)
    version = getattr(module, "__version__", "<unknown>")
    print(f"{label}: {version}")

try:
    mlflow = importlib.import_module("mlflow")
except ModuleNotFoundError:
    print("MLflow: not installed (optional)")
else:
    print(f"MLflow: {getattr(mlflow, '__version__', '<unknown>')}")
PY

RUN if /app/venv/bin/pip freeze | grep -qi nvidia; then \
        echo 'Unexpected NVIDIA packages found' >&2; \
        exit 1; \
    else \
        echo 'No NVIDIA packages installed'; \
    fi

# Use a dedicated non-root user for runtime
RUN groupadd --system bot && useradd --system --gid bot --home-dir /home/bot --shell /bin/bash bot && \
    mkdir -p /home/bot && \
    chown -R bot:bot /app /home/bot

USER bot

CMD ["/app/venv/bin/python", "-m", "bot.trading_bot"]
