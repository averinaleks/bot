# syntax=docker/dockerfile:1.6

FROM python:3.11-slim AS builder
ARG DEBIAN_FRONTEND=noninteractive

# Поведение Python по умолчанию с буферизацией stdout усложняет отладку
# журналов в GitHub Actions. Выключаем буферизацию сразу в базовом образе,
# чтобы любые ``print``-сообщения появлялись мгновенно.
ENV PYTHONUNBUFFERED=1

# Обновляем индекс пакетов и устанавливаем минимальный набор инструментов,
# необходимый для сборки виртуального окружения. Semgrep (правило
# ``dockerfile.security.apt-get-upgrade``) запрещает использование
# ``apt-get upgrade``, поэтому поддержка безопасности возлагается на
# своевременное обновление базового образа. Использование официального
# python:3.11-slim по-прежнему избавляет от ручных PPA и «Release file not
# found» в GitHub Actions.
RUN <<'EOSHELL'
set -eux
apt-get update
apt-get install -y --no-install-recommends \
    build-essential \
    ca-certificates \
    curl
rm -rf /var/lib/apt/lists/*
EOSHELL

WORKDIR /app

COPY requirements-core.txt .

ENV VIRTUAL_ENV=/opt/venv

# Строго убеждаемся, что в сборочном образе доступен Python 3.11. Именно
# отсутствие бинарника python3.11 в прошлых сборках вызывало падения "exit
# code 127" на шаге docker-publish. Такой ранний контроль делает причину
# проблемы очевидной и предотвращает регресс при смене базового образа.
RUN python - <<'PY'
import sys
major, minor = sys.version_info[:2]
if (major, minor) != (3, 11):
    raise SystemExit(
        f"Builder Python version mismatch: expected 3.11, got {major}.{minor}"
    )
PY

# ``python:3.11-slim`` поставляется с устаревшим setuptools 65.5.1,
# уязвимым к CVE-2024-6345 и CVE-2025-47273. Обновляем системные
# packaging-инструменты до безопасных версий до того, как начнём собирать
# виртуальное окружение, чтобы Trivy не находил high/critical уязвимости
# прямо в базовом образе.
RUN python -m pip install --no-cache-dir --upgrade \
        'pip>=24.0' \
        'setuptools>=80.9.0,<81' \
        wheel \
    && python -m pip cache purge

# pip>=24.0 устраняет CVE-2023-32681, setuptools>=80.9.0 закрывает известные
# уязвимости и совместимы с зависимостями проекта.
RUN python -m venv "$VIRTUAL_ENV"

RUN "$VIRTUAL_ENV"/bin/python -m ensurepip --upgrade

RUN "$VIRTUAL_ENV"/bin/pip install --no-cache-dir \
        'pip>=24.0' \
        'setuptools>=80.9.0,<81' \
        wheel

RUN "$VIRTUAL_ENV"/bin/pip install --no-cache-dir \
        --extra-index-url https://download.pytorch.org/whl/cpu \
        -r requirements-core.txt

RUN "$VIRTUAL_ENV"/bin/python - <<'PY'
import textwrap

exec(textwrap.dedent("""
    import hashlib
    import pathlib
    import sys
    from tempfile import NamedTemporaryFile
    from urllib.parse import urlsplit

    import requests
    from requests.adapters import HTTPAdapter
    from requests.exceptions import RequestException
    from urllib3.util.retry import Retry

    COMMONS_LANG3_URL = (
        "https://repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.18.0/"
        "commons-lang3-3.18.0.jar"
    )
    COMMONS_LANG3_SHA256 = (
        "4eeeae8d20c078abb64b015ec158add383ac581571cddc45c68f0c9ae0230720"
    )
    COMMONS_LANG3_ALLOWED_HOST = "repo1.maven.org"

    def update_commons_lang3() -> None:
        try:
            import ray  # type: ignore
        except Exception:
            print("Ray отсутствует, пропускаем обновление commons-lang3")
            return

        jars_dir = pathlib.Path(ray.__file__).resolve().parent / "jars"
        jars_dir.mkdir(parents=True, exist_ok=True)
        destination = jars_dir / "commons-lang3-3.18.0.jar"
        existing_jars = list(jars_dir.glob("commons-lang3-*.jar"))

        parsed_url = urlsplit(COMMONS_LANG3_URL)
        if parsed_url.scheme != "https":
            raise RuntimeError(
                "Ожидалась схема https при скачивании commons-lang3, "
                f"получено: {parsed_url.scheme}"
            )
        if parsed_url.netloc != COMMONS_LANG3_ALLOWED_HOST:
            raise RuntimeError(
                "Получен неожиданный хост при скачивании commons-lang3: "
                f"{parsed_url.netloc}"
            )

        hasher = hashlib.sha256()
        retries = Retry(
            total=5,
            backoff_factor=1.5,
            status_forcelist=(429, 500, 502, 503, 504),
            allowed_methods=("HEAD", "GET"),
        )

        temp_path = None
        try:
            with requests.Session() as session:
                session.mount("https://", HTTPAdapter(max_retries=retries))
                session.trust_env = False
                with session.get(
                    COMMONS_LANG3_URL,
                    stream=True,
                    timeout=30,
                    allow_redirects=False,
                ) as response:
                    if 300 <= response.status_code < 400:
                        location = response.headers.get("Location", "")
                        raise RuntimeError(
                            "commons-lang3 download unexpectedly redirected"
                            + (f" to {location}" if location else "")
                        )
                    response.raise_for_status()
                    with NamedTemporaryFile(
                        "wb", delete=False, dir=jars_dir
                    ) as temp_file:
                        temp_path = pathlib.Path(temp_file.name)
                        for chunk in response.iter_content(chunk_size=8192):
                            if not chunk:
                                continue
                            temp_file.write(chunk)
                            hasher.update(chunk)
        except RequestException as exc:
            if temp_path is not None:
                temp_path.unlink(missing_ok=True)
            print(
                "Не удалось скачать commons-lang3:"
                f" {exc!r}. Используем версию из поставки Ray.",
                file=sys.stderr,
            )
            return
        except Exception:
            if temp_path is not None:
                temp_path.unlink(missing_ok=True)
            raise

        if temp_path is None:
            raise RuntimeError("Failed to create temporary commons-lang3 download")

        digest = hasher.hexdigest()
        if digest != COMMONS_LANG3_SHA256:
            temp_path.unlink(missing_ok=True)
            raise RuntimeError(
                "SHA256 mismatch while downloading commons-lang3: expected "
                f"{COMMONS_LANG3_SHA256}, got {digest}"
            )

        for jar in existing_jars:
            jar.unlink(missing_ok=True)

        try:
            temp_path.replace(destination)
        except Exception:
            temp_path.unlink(missing_ok=True)
            raise

    update_commons_lang3()
"""))
PY

# NOTE: keep the cleanup below in a dedicated RUN step. Using an explicit Bash
# invocation with ``set -euo pipefail`` prevents the Docker parser from
# splitting the first command token (``nvidia_packages=...``) into a separate
# instruction, a behaviour that historically produced "dockerfile parse error"
# failures in the docker-publish workflow. Historical context:
# https://github.com/averinaleks/bot/actions/workflows/docker-publish.yml

RUN /bin/bash -euo pipefail -c "\
  nvidia_packages=\"\$($VIRTUAL_ENV/bin/pip freeze | grep -i '^nvidia-' || true)\"; \
  if [ -n \"\$nvidia_packages\" ]; then \
    printf '%s\\n' \"\$nvidia_packages\" | cut -d= -f1 | xargs -r $VIRTUAL_ENV/bin/pip uninstall -y; \
  else \
    echo 'No NVIDIA packages detected in the virtual environment'; \
  fi; \
  find \"$VIRTUAL_ENV\" -type d -name '__pycache__' -exec rm -rf {} +; \
  find \"$VIRTUAL_ENV\" -type f -name '*.pyc' -delete\
"

FROM python:3.11-slim
ARG DEBIAN_FRONTEND=noninteractive

ENV PYTHONUNBUFFERED=1

# Обновляем индекс пакетов и добавляем только необходимые зависимости
# выполнения. ``libstdc++6`` и ``libgcc-s1`` требуются бинарям PyTorch/
# TorchMetrics, ``libgomp1`` — NumPy/Scikit-learn, а ``libssl3`` —
# криптографическим библиотекам. ``apt-get upgrade`` не используется во
# исполнение требования Semgrep ``dockerfile.security.apt-get-upgrade``.
RUN <<'EOSHELL'
set -eux
apt-get update
apt-get install -y --no-install-recommends \
    libgcc-s1 \
    libgomp1 \
    libstdc++6 \
    libssl3
rm -rf /var/lib/apt/lists/*
EOSHELL

# Проверяем, что рантайм тоже использует Python 3.11. Это гарантирует,
# что окружение исполнения совпадает со сборочным и мы не столкнёмся с
# несовместимостью зависимостей.
RUN python - <<'PY'
import sys
major, minor = sys.version_info[:2]
if (major, minor) != (3, 11):
    raise SystemExit(
        f"Runtime Python version mismatch: expected 3.11, got {major}.{minor}"
    )
PY

# Аналогично стадии сборки обновляем системный pip/setuptools, чтобы в
# рантайме не оставалось уязвимых версий из базового образа.
RUN python -m pip install --no-cache-dir --upgrade \
        'pip>=24.0' \
        'setuptools>=80.9.0,<81' \
        wheel \
    && python -m pip cache purge

WORKDIR /app

COPY --from=builder /opt/venv /app/venv
COPY . .

ENV VIRTUAL_ENV=/app/venv
ENV PATH="$VIRTUAL_ENV/bin:$PATH"

# Verify that all heavy packages were installed and no GPU libraries remain.
# ``mlflow`` is an optional dependency and may be absent in the base image, so
# we report its status without failing the build when it's not installed.
RUN $VIRTUAL_ENV/bin/python - <<'PY'
import importlib

print("Checking package versions...")

required_modules = (
    ("torch", "Torch"),
    ("stable_baselines3", "SB3"),
    ("pytorch_lightning", "Lightning"),
)

for module_name, label in required_modules:
    module = importlib.import_module(module_name)
    version = getattr(module, "__version__", "<unknown>")
    print(f"{label}: {version}")

try:
    mlflow = importlib.import_module("mlflow")
except ModuleNotFoundError:
    print("MLflow: not installed (optional)")
else:
    print(f"MLflow: {getattr(mlflow, '__version__', '<unknown>')}")
PY

RUN if /app/venv/bin/pip freeze | grep -qi nvidia; then \
        echo 'Unexpected NVIDIA packages found' >&2; \
        exit 1; \
    else \
        echo 'No NVIDIA packages installed'; \
    fi

# Use a dedicated non-root user for runtime
RUN groupadd --system bot && useradd --system --gid bot --home-dir /home/bot --shell /bin/bash bot && \
    mkdir -p /home/bot && \
    chown -R bot:bot /app /home/bot

USER bot

CMD ["/app/venv/bin/python", "-m", "bot.trading_bot"]
